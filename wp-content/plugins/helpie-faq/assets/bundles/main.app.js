(()=>{var __webpack_modules__={"./assets/js/components/faq/accordion.js":module=>{eval('var Accordion = {\n  displayMode: "",\n  collectionProps: [],\n  itemsProps: [],\n  enabledFaqStyle: 0,\n  init: function init(viewProps) {\n    this.itemsProps = viewProps.items;\n    this.collectionProps = viewProps.collection;\n    this.displayMode = this.collectionProps.display_mode;\n    this.enabledFaqStyles = this.collectionProps.enable_faq_styles;\n  },\n  getAccordions: function getAccordions() {\n    var self = this;\n    var content = "";\n    for (var ii = 0; ii < this.itemsProps.length; ii++) {\n      if (this.itemsProps[ii].length == 0) {\n        continue;\n      }\n      content += self.getAccordion(this.itemsProps[ii]);\n    }\n    return content;\n  },\n  getAccordion: function getAccordion(props) {\n    var self = this;\n    var ID = props.post_id ? "post-" + props.post_id : "terms-" + props.term_id;\n    var titleIconType = props.post_id ? "title_icon" : "category_title_icon";\n    var accordionStyles = self.getAccordionStyles();\n    var urlAttribute = self.getUrlAttribute(props);\n    var titleIcon = self.getTitleIcon(titleIconType);\n    var customToggleIcon = self.getCustomToggleIcon();\n    var accordionBodyStyles = "";\n    var accordionHeaderClasses = "";\n    var titleContent = titleIcon + props.title;\n    var content = "";\n\n    /** show all FAQs are open when the display mode value as "open_all_faqs" */\n    if (this.collectionProps.open_by_default == "open_all_faqs") {\n      accordionHeaderClasses += " active";\n      accordionBodyStyles += "display:block;";\n    }\n\n    /** Adding the custom icon selector when using the custom icons  */\n    if (customToggleIcon != "") {\n      accordionHeaderClasses += " custom-icon";\n    }\n    if (this.collectionProps.icon_position == "left" && this.enabledFaqStyles == "1" && this.displayMode != "faq_list") {\n      accordionHeaderClasses += " accordion__icon__position--ltr";\n    }\n    accordionBodyStyles = accordionBodyStyles + accordionStyles.body_background;\n    content += \'<li class="accordion__item">\';\n    content += \'<div class="accordion__header \' + accordionHeaderClasses + \'" data-id="\' + ID + \'" data-item="\' + urlAttribute + \'" data-tags="\' + props.tags + \'" style="\' + accordionStyles.header_background + \'">\';\n    content += self.getAccordionHeaderContentByTag(titleContent);\n    content += customToggleIcon;\n    content += "</div>";\n    content += \'<div class="accordion__body" style="\' + accordionBodyStyles + \'">\';\n    content += props.content;\n    content += "</div>";\n    content += "</li>";\n    return content;\n  },\n  getUrlAttribute: function getUrlAttribute(props) {\n    var urlAttributeEnabled = this.collectionProps.faq_url_attribute == "1" ? true : false;\n    if (!urlAttributeEnabled) {\n      return "";\n    }\n    var ID = props.post_id ? "post-" + props.post_id : "terms-" + props.term_id;\n    var urlType = this.collectionProps.faq_url_type;\n    var attribute = "";\n    if (urlType == "post_slug" && helpie_faq_object.plan === "premium") {\n      var slug = props.slug.toLowerCase();\n      attribute = slug.replace(" ", "-");\n    } else {\n      attribute = "hfaq-" + ID;\n    }\n    return attribute;\n  },\n  getTitleIcon: function getTitleIcon(iconType) {\n    var content = "";\n    var icon = iconType == "title_icon" ? this.collectionProps.title_icon : this.collectionProps.category_title_icon;\n    if (icon == "" || this.enabledFaqStyles != "1") {\n      return content;\n    }\n    content = \'<span class="accordion__title-icon"><i class="faq-title-icon \' + icon + \'"></i></span>\';\n    return content;\n  },\n  getCustomToggleIcon: function getCustomToggleIcon() {\n    var content = "";\n    if (this.displayMode == "faq_list" || this.enabledFaqStyles != "1") {\n      return content;\n    }\n    var toggleClasses = this.collectionProps.open_by_default == "open_all_faqs" ? " open-all" : "";\n    if (this.collectionProps.toggle_icon_type === "custom" && this.collectionProps.toggle_open != "" && this.collectionProps.toggle_off != "") {\n      content = \'<span class="accordion__toggle \' + toggleClasses + \'">\';\n      content += \'<span class="accordion__toggle--open"><i class="accordion__toggle-icons \' + this.collectionProps.toggle_open + \'"></i></span>\';\n      content += \'<span class="accordion__toggle--close"><i class="accordion__toggle-icons \' + this.collectionProps.toggle_off + \'"></i></span>\';\n      content += "</span>";\n    }\n    return content;\n  },\n  getAccordionStyles: function getAccordionStyles() {\n    var header = "";\n    var body = "";\n    if (this.collectionProps.accordion_background != "") {\n      header = "background:" + this.collectionProps.accordion_background.header;\n      body = "background:" + this.collectionProps.accordion_background.body;\n    }\n    return {\n      header_background: header,\n      body_background: body\n    };\n  },\n  getAccordionHeaderTag: function getAccordionHeaderTag() {\n    var self = this;\n    var allowedTags = self.getAllowedHeaderTags();\n    var titleTag = this.collectionProps.accordion_header_tag != "" ? this.collectionProps.accordion_header_tag : "default";\n    var canUseCustomTag = allowedTags[titleTag] && helpie_faq_object.plan === "premium" && this.enabledFaqStyles == "1";\n    return canUseCustomTag && titleTag != "default" && titleTag != "p" ? titleTag : "div";\n  },\n  getAllowedHeaderTags: function getAllowedHeaderTags() {\n    return {\n      h1: "Heading 1",\n      h2: "Heading 2",\n      h3: "Heading 3",\n      h4: "Heading 4",\n      h5: "Heading 5",\n      h6: "Heading 6",\n      p: "Paragraph"\n    };\n  },\n  getAccordionHeaderContentByTag: function getAccordionHeaderContentByTag(titleContent) {\n    var self = this;\n    var accordionHeaderTag = self.getAccordionHeaderTag();\n    var content = "";\n    content += "<" + accordionHeaderTag + " class=\'accordion__title\'>";\n    content += titleContent;\n    content += "</" + accordionHeaderTag + ">";\n    return content;\n  }\n};\nmodule.exports = Accordion;\n\n//# sourceURL=webpack://helpie-faq/./assets/js/components/faq/accordion.js?')},"./assets/js/components/faq/collections.js":module=>{eval("var FaqCollections = {\n  getFaqs: function getFaqs(data) {\n    var self = this;\n    var viewProps = self.getCurrentShortcodeViewProps(data.shortcodeIndex);\n    return self.getCurrentPageViewProps(data, viewProps);\n  },\n  getCurrentShortcodeViewProps: function getCurrentShortcodeViewProps(shortcodeIndex) {\n    var globalFaqs = window.HELPIE_FAQS;\n    return globalFaqs[shortcodeIndex];\n  },\n  getCurrentPageViewProps: function getCurrentPageViewProps(data, viewProps) {\n    var self = this;\n    var limit = viewProps.collection.limit;\n    var startIndex = parseInt(data.page) * parseInt(limit);\n    var endIndex = parseInt(startIndex) + parseInt(limit);\n    var itemsProps = viewProps.items;\n    var collection = viewProps.collection;\n    collection.total_no_of_pages = self.getTotalNoOfPages(viewProps);\n    slicedItems = itemsProps.slice(startIndex, endIndex);\n    return {\n      collection: viewProps.collection,\n      items: slicedItems\n    };\n  },\n  getTotalNoOfPages: function getTotalNoOfPages(currentViewProps) {\n    var itemsProps = currentViewProps.items;\n    var count = itemsProps.length;\n    var limit = currentViewProps.collection.limit;\n    // if (count < limit) {\n    //     return 0;\n    // }\n    var pages = Math.ceil(parseInt(count) / parseInt(limit));\n    return pages > 1 ? pages - 1 : 0;\n  }\n};\nmodule.exports = FaqCollections;\n\n//# sourceURL=webpack://helpie-faq/./assets/js/components/faq/collections.js?")},"./assets/js/components/faq/functions.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var Accordion = __webpack_require__(/*! ../faq/accordion.js */ "./assets/js/components/faq/accordion.js");\nvar selectors = {\n  root: ".helpie-faq",\n  accordion: ".accordion",\n  accordionHide: "accordion--hide",\n  pagination: ".helpie-faq__pagination"\n};\nvar FaqFunctions = {\n  getElements: function getElements(element) {\n    var root = jQuery(element).closest(selectors.root);\n    var accordion = root.find(selectors.accordion);\n    var pagination = root.find(selectors.pagination);\n    return {\n      root: root,\n      pagination: pagination,\n      current: jQuery(element),\n      accordion: accordion\n    };\n  },\n  getShortcodeIndex: function getShortcodeIndex(elementsObject) {\n    var shortcodeIndex = jQuery(elementsObject.root).attr("data-shortcode-index");\n\n    // let index = 0;\n    // jQuery(selectors.root).each(function () {\n    // \tif (jQuery(this).index() == jQuery(elementsObject.root).index()) {\n    // \t\tshortcodeIndex = index;\n    // \t}\n    // \tindex = parseInt(index) + 1;\n    // });\n    return parseInt(shortcodeIndex);\n  },\n  getCollectionPropsFromHtml: function getCollectionPropsFromHtml(elementsObject) {\n    var collection = jQuery(elementsObject.root).attr("data-collection");\n    var props = {};\n    if (collection !== undefined && collection !== "undefined" && collection != "") {\n      props = JSON.parse(collection);\n    }\n    return props;\n  },\n  getPaginationCurrentPage: function getPaginationCurrentPage(elementsObject) {\n    var pageNo = jQuery(elementsObject.root).attr("data-pagination");\n    pageNo = pageNo == undefined ? 0 : parseInt(pageNo);\n    return pageNo;\n  },\n  paginationEnabled: function paginationEnabled(element) {\n    var self = this;\n    var elementsObject = self.getElements(element);\n    return elementsObject.pagination.length > 0 ? "1" : "0";\n  },\n  searchTermFromFaqObject: function searchTermFromFaqObject(items, searchTerm) {\n    var self = this;\n    var searchItems = [];\n    items.forEach(function (props, index) {\n      var titleMatch = self.isTitleMatch(props, searchTerm);\n      var contentMatch = self.isContentMatch(props, searchTerm);\n      var tagsMatch = self.searchByTags(props, searchTerm);\n      var addItem = titleMatch || contentMatch || tagsMatch ? true : false;\n      if (addItem) {\n        searchItems.push(props);\n      }\n    });\n    return searchItems;\n  },\n  isTitleMatch: function isTitleMatch(props, searchTerm) {\n    var title = props.title.toLowerCase();\n    return title.search(searchTerm) < 0 ? false : true;\n  },\n  isContentMatch: function isContentMatch(props, searchTerm) {\n    var stripedContent = props.content.replace(/<[^>]+>/g, "");\n    stripedContent = stripedContent.toLowerCase();\n    return stripedContent.search(searchTerm) < 0 ? false : true;\n  },\n  searchByTags: function searchByTags(props, searchTerm) {\n    var foundTag = false;\n    if (props.tags == undefined || props.tags == "undefined" || props.tags.length == 0) {\n      return foundTag;\n    }\n    props.tags.split(",").forEach(function (tag) {\n      tag = tag.toLowerCase();\n      if (tag.search(searchTerm) != -1) {\n        foundTag = true;\n      }\n    });\n    return foundTag;\n  },\n  appendFaqsContent: function appendFaqsContent(elementsObject, thisPageViewProps) {\n    var self = this;\n    var faqsContent = self.getFaqsContent(thisPageViewProps);\n    jQuery(elementsObject.accordion).removeClass(selectors.accordionHide).empty().append(faqsContent);\n\n    /** Set search attributes after rendering the accordions  */\n    self.setSearchAttributes(elementsObject);\n\n    /***  scroll up the page to closest accordion position when update DOM.  */\n    self.moveToTop(elementsObject);\n  },\n  /** Get the accordion HTML Content */\n  getFaqsContent: function getFaqsContent(viewProps) {\n    Accordion.init(viewProps);\n    return Accordion.getAccordions();\n  },\n  setSearchAttributes: function setSearchAttributes(elementsObject) {\n    /* Add \'search_attr\' to accordion headers */\n    jQuery(elementsObject.root).find(".accordion__item").each(function () {\n      var searchAttr = jQuery(this).text().toLowerCase();\n      jQuery(this).attr("data-search-term", searchAttr);\n    });\n  },\n  moveToTop: function moveToTop(elementsObject) {\n    var accordionPosition = jQuery(elementsObject.accordion).offset().top;\n    accordionPosition = parseInt(accordionPosition) - parseInt(70);\n    window.scrollTo({\n      top: accordionPosition,\n      behavior: "smooth"\n    });\n  }\n};\nmodule.exports = FaqFunctions;\n\n//# sourceURL=webpack://helpie-faq/./assets/js/components/faq/functions.js?')},"./assets/js/components/faq/object_search.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var FaqCollections = __webpack_require__(/*! ./collections.js */ "./assets/js/components/faq/collections.js");\nvar Pagination = __webpack_require__(/*! ./pagination.js */ "./assets/js/components/faq/pagination.js");\nvar Accordion = __webpack_require__(/*! ./accordion.js */ "./assets/js/components/faq/accordion.js");\nvar FaqFunctions = __webpack_require__(/*! ./functions.js */ "./assets/js/components/faq/functions.js");\nvar ObjectSearch = {\n  init: function init(searchElement, searchTerm) {\n    var elementsObject = FaqFunctions.getElements(searchElement);\n    var shortcodeIndex = FaqFunctions.getShortcodeIndex(elementsObject);\n    var viewPropsBySearchingTerm = FaqCollections.getCurrentShortcodeViewProps(shortcodeIndex);\n    var searchTermFoundItems = FaqFunctions.searchTermFromFaqObject(viewPropsBySearchingTerm.items, searchTerm);\n    var totalNoOfPage = FaqCollections.getTotalNoOfPages({\n      collection: viewPropsBySearchingTerm.collection,\n      items: searchTermFoundItems\n    });\n    var currentPageNO = jQuery(elementsObject.pagination).find(".helpie-faq__pagination__listItem .helpie-faq__pagination__listItem--anchor.active").attr("data-page");\n    currentPageNO = currentPageNO == undefined ? 0 : parseInt(currentPageNO);\n    var data = {\n      page: currentPageNO,\n      shortcodeIndex: shortcodeIndex\n    };\n    var currentPageProps = FaqCollections.getCurrentPageViewProps(data, {\n      collection: viewPropsBySearchingTerm.collection,\n      items: searchTermFoundItems\n    });\n    Accordion.init({\n      collection: viewPropsBySearchingTerm.collection,\n      items: currentPageProps.items\n    });\n    var accordionsContent = Accordion.getAccordions();\n    jQuery(elementsObject.accordion).removeClass("accordion--hide").empty().append(accordionsContent);\n    Pagination.renderPageLinks(elementsObject.pagination, {\n      current: data.page,\n      last: totalNoOfPage\n    });\n    return searchTerm;\n  }\n};\nmodule.exports = ObjectSearch;\n\n//# sourceURL=webpack://helpie-faq/./assets/js/components/faq/object_search.js?')},"./assets/js/components/faq/pagination.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var FaqCollections = __webpack_require__(/*! ../faq/collections.js */ "./assets/js/components/faq/collections.js");\nvar FaqFunctions = __webpack_require__(/*! ../faq/functions.js */ "./assets/js/components/faq/functions.js");\nvar selectors = {\n  pagination: ".helpie-faq__pagination",\n  paginationHide: "helpie-faq__pagination--hide",\n  pages: ".helpie-faq__pagination__listItem .helpie-faq__pagination__listItem--anchor"\n};\nvar Pagination = {\n  init: function init() {\n    this.events();\n  },\n  events: function events() {\n    var self = this;\n    jQuery(selectors.pagination).on("click", selectors.pages, function () {\n      self.loadFAQs(this);\n    });\n  },\n  loadFAQs: function loadFAQs(element) {\n    var self = this;\n    var page = jQuery(element).attr("data-page");\n    var totalNoOfPage = self.getTotalNoOfPage(element);\n    var currentPage = self.getCurrentPage(element);\n\n    /** The page should preb or next */\n    if (page instanceof String || typeof page == "string") {\n      if (page == "PREV") {\n        if (currentPage == 0) {\n          return false;\n        }\n        page = parseInt(currentPage) - 1;\n      } else if (page == "NEXT") {\n        if (parseInt(currentPage) === parseInt(totalNoOfPage)) {\n          return false;\n        }\n        page = parseInt(currentPage) + 1;\n      }\n    }\n    var elementsObject = FaqFunctions.getElements(element);\n    var args = FaqFunctions.getCollectionPropsFromHtml(elementsObject);\n    args.search_term = self.getSearchValue(elementsObject);\n    args.page = page;\n    self.setFAQs(args, elementsObject);\n\n    /** Don\'t update paginate current page no if searching the FAQs    */\n    var searchingFaqs = jQuery(elementsObject.root).attr("data-search");\n    if (searchingFaqs == 0) {\n      jQuery(elementsObject.root).attr("data-pagination", page);\n    }\n  },\n  setFAQs: function setFAQs(data, elementsObject) {\n    var self = this;\n    var shortcodeIndex = FaqFunctions.getShortcodeIndex(elementsObject);\n    data.shortcodeIndex = shortcodeIndex;\n    var viewProps = FaqCollections.getCurrentShortcodeViewProps(shortcodeIndex);\n    var thisPageFaqItems = viewProps.items;\n    var totalNoOfPage = FaqCollections.getTotalNoOfPages(viewProps);\n    if (data.search_term != "" && data.search_term != undefined && data.search_term != "undefined") {\n      var searchTermFoundItems = FaqFunctions.searchTermFromFaqObject(thisPageFaqItems, data.search_term);\n      totalNoOfPage = FaqCollections.getTotalNoOfPages({\n        collection: viewProps.collection,\n        items: searchTermFoundItems\n      });\n      thisPageFaqItems = searchTermFoundItems;\n    }\n    var thisPageViewProps = FaqCollections.getCurrentPageViewProps(data, {\n      collection: viewProps.collection,\n      items: thisPageFaqItems\n    });\n\n    /*** Appending the current page FAQs content  */\n    FaqFunctions.appendFaqsContent(elementsObject, thisPageViewProps);\n    /** Re-render the paginations */\n    self.renderPageLinks(elementsObject.pagination, {\n      current: data.page,\n      last: totalNoOfPage\n    });\n\n    // self.loader(elementsObject.pagination, false);\n  },\n\n  loader: function loader(element, canShow) {\n    var addClassName = canShow == true ? "active" : "";\n    var removeClassName = canShow == false ? "active" : "";\n    jQuery(element).closest(selectors.pagination).find(".helpie-faq__spinner").removeClass(removeClassName).addClass(addClassName);\n  },\n  getCurrentPage: function getCurrentPage(element) {\n    var pageNo = jQuery(element).closest(selectors.pagination).find(selectors.pages + ".active").attr("data-page");\n    pageNo = pageNo == undefined ? 0 : parseInt(pageNo);\n    return pageNo;\n  },\n  getTotalNoOfPage: function getTotalNoOfPage(element) {\n    var totalNoOfPageNo = jQuery(element).closest(selectors.pagination).find(selectors.pages).last().attr("data-page");\n    return parseInt(totalNoOfPageNo);\n  },\n  renderPageLinks: function renderPageLinks(paginationElement, page) {\n    var self = this;\n    var htmlContent = "";\n\n    // if (page.last == 0) {\n    //     jQuery(paginationElement).addClass(selectors.paginationHide);\n    //     return;\n    // }\n\n    htmlContent += self.getPageLink({\n      page: 0,\n      label: "First"\n    });\n    htmlContent += self.getPageLink({\n      page: "PREV",\n      label: "Previous"\n    });\n    htmlContent += self.getPagesLinks(page.last, page.current);\n    htmlContent += self.getPageLink({\n      page: "NEXT",\n      label: "Next"\n    });\n    htmlContent += self.getPageLink({\n      page: page.last,\n      label: "Last"\n    });\n    jQuery(paginationElement).removeClass(selectors.paginationHide).find(".helpie-faq__pagination__list").empty().append(htmlContent);\n  },\n  getPagesLinks: function getPagesLinks(totalNoOfPages, currentPage) {\n    var self = this;\n    var buttons = [-2, -1, 0, 1, 2];\n    var htmlContent = "";\n    for (buttonItr = 0; buttonItr < buttons.length; buttonItr++) {\n      var button = buttons[buttonItr];\n      var pageNo = parseInt(currentPage) + parseInt(button);\n      var active = pageNo == currentPage ? "active" : "";\n      if (pageNo >= 0 && pageNo <= totalNoOfPages) {\n        htmlContent += self.getPageLink({\n          classes: active,\n          page: pageNo,\n          label: parseInt(pageNo) + 1\n        });\n      }\n    }\n    return htmlContent;\n  },\n  getPageLink: function getPageLink(args) {\n    var classes = typeof args.classes == "undefined" ? "" : args.classes;\n    var htmlContent = "";\n    htmlContent += \'<li class="helpie-faq__pagination__listItem">\';\n    htmlContent += \'<a class="helpie-faq__pagination__listItem--anchor \' + classes + \' " data-page="\' + args.page + \'">\' + args.label + "</a>";\n    htmlContent += "</li>";\n    return htmlContent;\n  },\n  getSearchValue: function getSearchValue(elementsObject) {\n    var searchInputElement = jQuery(elementsObject.root).find(".search__input");\n    if (searchInputElement.length == 0) {\n      return "";\n    }\n    return searchInputElement.val().toLowerCase().replace(/[.*+?^${}()|[\\]\\\\]/gi, "");\n  }\n};\nmodule.exports = Pagination;\n\n//# sourceURL=webpack://helpie-faq/./assets/js/components/faq/pagination.js?')},"./assets/js/components/faq/seach_by_attribute.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var FaqCollections = __webpack_require__(/*! ./collections.js */ "./assets/js/components/faq/collections.js");\nvar FaqFunctions = __webpack_require__(/*! ./functions.js */ "./assets/js/components/faq/functions.js");\nvar Pagination = __webpack_require__(/*! ./pagination.js */ "./assets/js/components/faq/pagination.js");\nvar SearchByAttributes = {\n  urlAttribute: "",\n  doSearch: function doSearch(urlAttribute) {\n    var self = this;\n    self.urlAttribute = urlAttribute;\n    jQuery(".helpie-faq").each(function () {\n      var paginationEnabled = jQuery(this).attr("data-pagination-enabled");\n      if (paginationEnabled === "1") {\n        var shortcodeIndex = jQuery(this).attr("data-shortcode-index");\n        var viewProps = FaqCollections.getCurrentShortcodeViewProps(shortcodeIndex);\n        var elementsObject = FaqFunctions.getElements(this);\n        self.searchByUrlAttribute(viewProps, elementsObject);\n      }\n    });\n  },\n  searchByUrlAttribute: function searchByUrlAttribute(viewProps, elementsObject) {\n    var self = this;\n    var itemsProps = viewProps.items;\n    var isPostSlugEnabled = self.urlAttribute.search("hfaq") < 0 ? true : false;\n    var accordionIndex = 0;\n    itemsProps.forEach(function (props, index) {\n      var hashURL = props.slug;\n      if (!isPostSlugEnabled) {\n        hashURL = "hfaq-post-" + props.post_id;\n      }\n      hashURL = "#" + hashURL;\n      if (self.urlAttribute == hashURL) {\n        accordionIndex = index;\n      }\n    });\n    var totalNoOfPage = FaqCollections.getTotalNoOfPages(viewProps);\n    var data = {\n      totalNoOfPage: totalNoOfPage,\n      accordionIndex: accordionIndex\n    };\n    var currentPage = self.getPageNumber(viewProps, data);\n    data.page = currentPage;\n    if (currentPage > 0) {\n      var pageViewProps = FaqCollections.getCurrentPageViewProps(data, viewProps);\n      FaqFunctions.appendFaqsContent(elementsObject, pageViewProps);\n      Pagination.renderPageLinks(elementsObject.pagination, {\n        current: currentPage,\n        last: totalNoOfPage\n      });\n    }\n  },\n  getPageNumber: function getPageNumber(viewProps, data) {\n    var limit = viewProps.collection.limit;\n    var pageNo = 0;\n    for (var ii = 0; ii <= data.totalNoOfPage; ii++) {\n      var startIndex = parseInt(ii) * parseInt(limit);\n      var endIndex = parseInt(startIndex) + parseInt(limit);\n      if (data.accordionIndex >= startIndex && data.accordionIndex <= endIndex) {\n        pageNo = ii;\n      }\n    }\n    return pageNo;\n  }\n};\nmodule.exports = SearchByAttributes;\n\n//# sourceURL=webpack://helpie-faq/./assets/js/components/faq/seach_by_attribute.js?')},"./assets/js/components/insights/tracker.js":module=>{eval('/* Triggered by FAQ events, integrates with Insights */\nvar Tracker = {\n  init: function init() {\n    this.nonce = helpie_faq_object.nonce;\n    // console.log("Track Me");\n    // setTimeout(() => {\n    // \tthis.detectWidgets();\n    // }, 3000);\n  },\n\n  /* EVENTS API */\n  searchCounter: function searchCounter(searchTerm) {\n    var thisModule = this;\n    var data = {\n      action: "helpie_faq_search_counter",\n      nonce: thisModule.nonce,\n      searchTerm: searchTerm\n    };\n    this.makeRequest(data);\n  },\n  /* Auto-ordering methods */\n  clickCounter: function clickCounter(id) {\n    var thisModule = this;\n    var data = {\n      action: "helpie_faq_click_counter",\n      nonce: thisModule.nonce,\n      id: id\n    };\n    this.makeRequest(data);\n  },\n  detectWidgets: function detectWidgets() {\n    // Elementor Widget\n    var doesElementorHaveHelpieFAQWidget = jQuery(".elementor-widget-helpie-faq").length;\n    var doesElementorHaveHelpieFAQDynamicWidget = jQuery(".elementor-widget-helpie-faq-dynamic-add").length;\n    var thisModule = this;\n    var data = {\n      action: "helpie_faq_track_shortcodes_and_widgets",\n      nonce: thisModule.nonce,\n      event_value: "",\n      event_name: ""\n    };\n    if (doesElementorHaveHelpieFAQWidget) {\n      data.event_value = "helpie_faq";\n      data.event_name = "Elementor Widget";\n      this.makeRequest(data);\n    }\n    if (doesElementorHaveHelpieFAQDynamicWidget) {\n      data.event_value = "helpie_faq_dynamic_add";\n      data.event_name = "Elementor Widget";\n      this.makeRequest(data);\n    }\n  },\n  /* INTERNAL METHODS */\n  makeRequest: function makeRequest(data) {\n    jQuery.post(helpie_faq_object.ajax_url, data, function (response) {\n      // console.log(response);\n    });\n  }\n};\nmodule.exports = Tracker;\n\n//# sourceURL=webpack://helpie-faq/./assets/js/components/insights/tracker.js?')},"./assets/js/components/submission/submission.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var SubmissionAjax = __webpack_require__(/*! ./submission_ajax.js */ "./assets/js/components/submission/submission_ajax.js");\nvar Submission = {\n  init: function init() {\n    var enabled_submission = helpie_faq_object.enabled_submission;\n    if (enabled_submission == "") {\n      return false;\n    }\n    this.eventHandler();\n  },\n  eventHandler: function eventHandler() {\n    this.initChosen();\n    this.toggleForm();\n    this.submitForm();\n    if (helpie_faq_object.plan == "premium") {\n      SubmissionAjax.getLoggedEmail();\n    }\n  },\n  initChosen: function initChosen() {\n    jQuery(".helpie-faq").find(".form__section .faq_categories").each(function () {\n      jQuery(this).chosen({\n        width: "100%"\n      });\n    });\n  },\n  submitForm: function submitForm() {\n    var thisModule = this;\n    jQuery(".helpie-faq").on("click", ".form__submit", function (e) {\n      e.stopPropagation();\n      var formSection = jQuery(this).closest(".form__section"),\n        question = formSection.find(".form__text").val(),\n        email = formSection.find(".form__email").val(),\n        answer = formSection.find(".form__textarea").val(),\n        wooProduct = formSection.data("woo-product"),\n        kbCategory = formSection.data("kb-category"),\n        categories = formSection.find(".faq_categories").val(),\n        faqGroupID = formSection.find("input[name=faq_group_id]").val(),\n        data = {\n          action: "helpie_faq_submission",\n          nonce: thisModule.nonce,\n          question: question,\n          categories: categories,\n          group_id: faqGroupID\n        };\n      if (email) data.email = email;\n      if (answer) data.answer = answer;\n      if (wooProduct) data.woo_product = wooProduct;\n      if (kbCategory) data.kb_category = kbCategory;\n      if (question && thisModule._isEmail(email) || question && email == undefined) {\n        e.preventDefault();\n        SubmissionAjax.postForm(data, formSection);\n      }\n    });\n  },\n  toggleForm: function toggleForm() {\n    jQuery(".helpie-faq").on("click", ".form__toggle", function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n      var formSection = jQuery(this).parent().next(".form__section");\n      var currentToggleButtonValue = this.value;\n      var toggleButtonValue = "";\n      formSection.next().hide();\n      if (currentToggleButtonValue === faqStrings.addFAQ) {\n        toggleButtonValue = faqStrings.hide;\n        formSection.show();\n      } else {\n        toggleButtonValue = faqStrings.addFAQ;\n        formSection.hide();\n      }\n      this.value = toggleButtonValue;\n    });\n  },\n  _isEmail: function _isEmail(email) {\n    var regex = /^([a-zA-Z0-9_\\.\\-\\+])+\\@(([a-zA-Z0-9\\-])+\\.)+([a-zA-Z0-9]{2,4})+$/;\n    return !regex.test(email) ? false : true;\n  }\n};\nmodule.exports = Submission;\n\n//# sourceURL=webpack://helpie-faq/./assets/js/components/submission/submission.js?')},"./assets/js/components/submission/submission_ajax.js":module=>{eval('var SubmissionAjax = {\n  postForm: function postForm(data, formSection) {\n    thisModule = this;\n    jQuery.post(helpie_faq_object.ajax_url, data, function (response) {\n      var ajaxResponse = JSON.parse(response);\n      // console.log(ajaxResponse);\n      if (ajaxResponse.postStatus == "publish") {\n        thisModule._successMessage(formSection);\n        /*** Reload the page insteead of appending the content */\n        // thisModule._appendItem(data, formSection);\n        setTimeout(function () {\n          location.reload();\n        }, 1000);\n        // console.log("Success Post Message");\n      } else if (ajaxResponse.postStatus == "pending") {\n        thisModule._successMessage(formSection);\n        // console.log("Success Pending Message");\n      }\n    });\n\n    var faqDefaultCategoryId = formSection.find(".faq_default_category_term_id").val();\n    // Empty input fields on submit\n    formSection.find(".form__text").val("");\n    formSection.find(".form__email").val("");\n    formSection.find(".form__textarea").val("");\n    formSection.find(".faq_categories").val(faqDefaultCategoryId).trigger("chosen:updated");\n    if (helpie_faq_object.plan == "premium") {\n      thisModule.getLoggedEmail();\n    }\n  },\n  getLoggedEmail: function getLoggedEmail() {\n    thisModule = this;\n    var data = {\n      action: "helpie_faq_submission_get_logged_email",\n      nonce: thisModule.nonce\n    };\n    var email = jQuery(".form__section .form__email");\n    if (email) {\n      jQuery.get(helpie_faq_object.ajax_url, data, function (response) {\n        var ajaxResponse = JSON.parse(response);\n        if (ajaxResponse.loggedEmail) {\n          email.val(ajaxResponse.loggedEmail);\n        }\n      });\n    }\n  },\n  _appendItem: function _appendItem(data, formSection) {\n    var accordion = formSection.parent().find(".accordion");\n    var reqData = {\n      action: "helpie_faq_submission_get_item",\n      nonce: thisModule.nonce,\n      title: data.question\n    };\n    reqData.content = data.answer ? data.answer : "Empty Content";\n    jQuery.post(helpie_faq_object.ajax_url, reqData, function (response) {\n      var ajaxResponse = JSON.parse(response);\n      accordion.append(ajaxResponse.singleItem);\n      // console.log(ajaxResponse);\n    });\n  },\n\n  _successMessage: function _successMessage(el) {\n    jQuery(el).hide();\n    jQuery(el).next().show();\n    jQuery(el).next().addClass("active");\n  }\n};\nmodule.exports = SubmissionAjax;\n\n//# sourceURL=webpack://helpie-faq/./assets/js/components/submission/submission_ajax.js?')},"./assets/js/main.js":(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony import */ var _svelte_qna_qna_svelte__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./svelte/qna/qna.svelte */ "./assets/js/svelte/qna/qna.svelte");\n/* harmony import */ var _css_main_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../css/main.scss */ "./assets/css/main.scss");\nvar Stylus = __webpack_require__(/*! ./../../lib/stylus/js/search.js */ "./lib/stylus/js/search.js");\nvar Tracker = __webpack_require__(/*! ./components/insights/tracker.js */ "./assets/js/components/insights/tracker.js");\nvar Submission = __webpack_require__(/*! ./components/submission/submission.js */ "./assets/js/components/submission/submission.js");\n// var Faqs = require("./components/faq/faqs.js");\nvar Pagination = __webpack_require__(/*! ./components/faq/pagination.js */ "./assets/js/components/faq/pagination.js");\nvar SearchByAttributes = __webpack_require__(/*! ./components/faq/seach_by_attribute.js */ "./assets/js/components/faq/seach_by_attribute.js");\n\nvar HelpieFaq = {\n  nonce: helpie_faq_object.nonce,\n  init: function init() {\n    // console.log("FAQ init");\n    this.setShortcodeIndex();\n    this.onPageLoadActions();\n    this.eventHandlers();\n\n    // Components\n    Tracker.init(this.nonce);\n\n    // Library Components\n    Stylus.init();\n\n    \n\n    /** Get all shortcode FAQs by shortcode args */\n    // Faqs.init();\n\n    Pagination.init();\n    this.initQnaApp();\n  },\n  initQnaApp: function initQnaApp() {\n    var props = {};\n    var targetElementId = \'helpie-qna-app\';\n    var rootElementClassName = \'helpie__qnaContainer\';\n    var svelteElement = document.getElementById(targetElementId);\n    if (!svelteElement) {\n      return;\n    }\n\n    // Step 2. Init FAQ Group Store\n    // props.store = this.getStore(props);\n    console.log(svelteElement);\n\n    // Step 3. Init FAQ Group Svelte App\n    new _svelte_qna_qna_svelte__WEBPACK_IMPORTED_MODULE_0__["default"]({\n      target: svelteElement,\n      props: props\n    });\n  },\n  setShortcodeIndex: function setShortcodeIndex() {\n    var index = 0;\n    jQuery(".helpie-faq").each(function () {\n      jQuery(this).attr("data-shortcode-index", index);\n      index++;\n    });\n  },\n  eventHandlers: function eventHandlers() {\n    var thisModule = this;\n    jQuery(".helpie-faq").on("click", ".accordion__header", function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n      var faq_list = thisModule.isFaqList(jQuery(this));\n      if (faq_list) {\n        return false;\n      }\n      thisModule.onHeaderClick(this);\n      var dataItem = jQuery(this).attr("data-item");\n      if (dataItem !== undefined && dataItem !== "undefined" && dataItem !== "") {\n        window.location.hash = jQuery(this).attr("data-item");\n      }\n    });\n    jQuery(".helpie-faq").on("click", ".accordion__title, .faq-title-icon", function (e) {\n      var $accordion__header = jQuery(this).closest(".accordion__header");\n      e.preventDefault();\n      e.stopPropagation();\n      var faq_list = thisModule.isFaqList(jQuery(this));\n      if (faq_list) {\n        return false;\n      }\n      thisModule.onHeaderClick($accordion__header);\n      var dataItem = $accordion__header.attr("data-item");\n      if (dataItem !== undefined && dataItem !== "undefined" && dataItem !== "") {\n        window.location.hash = $accordion__header.attr("data-item");\n      }\n    });\n  },\n  openFirstAccordion: function openFirstAccordion() {\n    jQuery(".helpie-faq.accordions.open-first > .accordion:first").each(function () {\n      var FirstItemHeaderSelector = ".accordion__item:first > .accordion__header";\n      jQuery(this).find(FirstItemHeaderSelector).addClass("active");\n      jQuery(this).find(FirstItemHeaderSelector).next(".accordion__body").stop().slideDown(300);\n    });\n  },\n  onPageLoadActions: function onPageLoadActions() {\n    var hashURL = window.location.hash;\n    var isHFAQAccordionOpened = false;\n    if (hashURL != "") {\n      SearchByAttributes.doSearch(hashURL);\n      isHFAQAccordionOpened = this.openHFaqAccordion(hashURL);\n    }\n    if (!isHFAQAccordionOpened) {\n      this.openFirstAccordion();\n    }\n  },\n  onHeaderClick: function onHeaderClick(that) {\n    var thisModule = this;\n    if (jQuery(that).hasClass("active")) {\n      thisModule.closeAccordion(that);\n    } else {\n      if (jQuery(that).closest(".helpie-faq.accordions").hasClass("faq-toggle")) {\n        jQuery(that).closest(".accordion").find(".accordion__header").removeClass("active");\n        jQuery(that).closest(".accordion").find(".accordion__body").slideUp();\n      }\n      thisModule.openAccordion(that);\n    }\n  },\n  openAccordion: function openAccordion(that) {\n    jQuery(that).addClass("active");\n    jQuery(that).next(".accordion__body").stop().slideDown(300);\n    /* Auto-ordering Event Tracker */\n    var id = jQuery(that).attr("data-id");\n    if (id) {\n      Tracker.clickCounter(id);\n    }\n  },\n  closeAccordion: function closeAccordion(that) {\n    jQuery(that).removeClass("active");\n    jQuery(that).next(".accordion__body").stop().slideUp(300);\n  },\n  openHFaqAccordion: function openHFaqAccordion(urlHashTagHFaqItem) {\n    var isItemFound = false;\n    jQuery(".helpie-faq.accordions .accordion .accordion__item").each(function () {\n      var HFaqItem = "#" + jQuery(this).find(".accordion__header").attr("data-item");\n      if (HFaqItem === urlHashTagHFaqItem) {\n        jQuery(this).find(".accordion__header").addClass("active");\n        jQuery(this).find(".accordion__header").next(".accordion__body").stop().slideDown(300);\n        var accordions = jQuery(this).parents(".accordion");\n        if (accordions.length > 0) {\n          // In display mode is category then, if need to active on category faq accordion also.\n          var categoryAccordion = jQuery(this).closest(".accordion").parent();\n          categoryAccordion.prev().addClass("active");\n          categoryAccordion.show();\n        }\n        var accordionHeaderPosition = jQuery(this).find(".accordion__header").offset().top;\n        accordionHeaderPosition = accordionHeaderPosition - parseInt(70);\n        window.scrollTo({\n          top: accordionHeaderPosition,\n          behavior: "smooth"\n        });\n        isItemFound = true;\n        return false;\n      }\n    });\n    return isItemFound;\n  },\n  isFaqList: function isFaqList(that) {\n    var faqListLength = jQuery(that).closest("article.faq_list").length;\n    return faqListLength;\n  }\n};\njQuery(document).ready(function () {\n  // window.HELPIE_FAQS = [];\n  console.log("*** MAIN ***");\n  console.log(window.HELPIE_FAQS);\n  HelpieFaq.init();\n  console.log("jquery");\n});\n\n\n//# sourceURL=webpack://helpie-faq/./assets/js/main.js?')},"./assets/js/svelte/qna/store.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* unused harmony export questions */\n/* harmony import */ var svelte_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/store */ "./node_modules/svelte/store/index.mjs");\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar questions = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.writable)({});\nvar Store = /*#__PURE__*/function () {\n  function Store() {\n    var _this = this;\n    _classCallCheck(this, Store);\n    _defineProperty(this, "questions", void 0);\n    _defineProperty(this, "viewableQuestions", []);\n    _defineProperty(this, "currentPage", void 0);\n    _defineProperty(this, "itemsPerPage", 5);\n    _defineProperty(this, "searchText", void 0);\n    _defineProperty(this, "numOfTotalPages", void 0);\n    this.searchText = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.writable)("");\n    this.currentPage = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.writable)(0);\n    this.questions = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.writable)([]);\n    this.viewableQuestions = this.getviewableQuestions();\n    this.numOfTotalPages = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.derived)(this.questions, function ($questions) {\n      return Math.ceil($questions.length / _this.itemsPerPage);\n    });\n  }\n  _createClass(Store, [{\n    key: "updateCurrentPage",\n    value: function updateCurrentPage(currentPage) {\n      this.currentPage.set(currentPage);\n      console.log(\'store.currentPage: \' + (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.get)(this.currentPage));\n    }\n  }, {\n    key: "getviewableQuestionsTest",\n    value: function getviewableQuestionsTest() {\n      var time = 100;\n      return (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.derived)(this.questions, function ($questions) {\n        return $questions.slice(0, 2);\n      });\n    }\n  }, {\n    key: "setSearchText",\n    value: function setSearchText(searchText) {\n      this.searchText.set(searchText);\n    }\n  }, {\n    key: "onPaginationChange",\n    value: function onPaginationChange(callbackName) {\n      var pageNumber;\n      var currentPage = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.get)(this.currentPage);\n      var numOfTotalPages = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.get)(this.numOfTotalPages);\n      switch (callbackName) {\n        case "previous":\n          pageNumber = currentPage - 1;\n          break;\n        case "next":\n          pageNumber = currentPage + 1;\n          break;\n        case "first":\n          pageNumber = 0;\n          break;\n        case "last":\n          pageNumber = numOfTotalPages - 1;\n          break;\n        default:\n          pageNumber = callbackName.split("-")[1];\n          pageNumber = parseInt(pageNumber);\n          break;\n      }\n      console.log("callbackName: " + callbackName);\n      console.log("pageNumber: " + pageNumber);\n      console.log("currentPage: " + currentPage);\n      if (0 > pageNumber || pageNumber > numOfTotalPages - 1) {\n        return;\n      }\n      this.updateCurrentPage(pageNumber);\n\n      // ActionsHandlerInstance.doAction({\n      // \ttype: "CHANGE_CURRENT_PAGE",\n      // \tpayload: {\n      // \t\tcurrentPage: pageNumber,\n      // \t},\n      // });\n    }\n  }, {\n    key: "getviewableQuestions",\n    value: function getviewableQuestions() {\n      var self = this;\n      console.log("getviewableQuestions: ");\n      return (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.derived)([this.questions, this.searchText, this.currentPage], function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 3),\n          $questions = _ref2[0],\n          $searchText = _ref2[1],\n          $currentPage = _ref2[2];\n        console.log("getviewableQuestions $questions: ");\n        console.log($questions);\n        return $questions.filter(function (question) {\n          if ($searchText == "") {\n            return true;\n          }\n          var isMatch = self.checkMatch(question, $searchText);\n          console.log("isMatch: " + isMatch);\n          return isMatch;\n        }).slice($currentPage * self.itemsPerPage, ($currentPage + 1) * self.itemsPerPage);\n      });\n    }\n  }, {\n    key: "setQuestions",\n    value: function setQuestions(questions) {\n      this.questions.set(questions);\n    }\n  }, {\n    key: "postVote",\n    value: function postVote(reqData) {\n      console.log("reqData: " + JSON.stringify(reqData));\n      jQuery.post(helpie_faq_object.ajax_url, reqData, function (response) {\n        var ajaxResponse = JSON.parse(response);\n        console.log(ajaxResponse);\n      });\n    }\n  }, {\n    key: "postItem",\n    value: function () {\n      var _postItem = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(postargs) {\n        var ajaxResponse, self, reqData;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                self = this;\n                reqData = postargs;\n                reqData.action = "helpie_qna_submission";\n                console.log("value: " + postargs.value);\n                console.log("reqData: " + JSON.stringify(reqData));\n\n                // await ajaxResponse = jQuery.post(helpie_faq_object.ajax_url, reqData, function (response) {\n                //     ajaxResponse = JSON.parse(response);\n                //     console.log(ajaxResponse);\n                //     self.getPosts(postargs);\n\n                //     return ajaxResponse;\n                // });\n                _context.next = 7;\n                return jQuery.post(helpie_faq_object.ajax_url, reqData);\n              case 7:\n                ajaxResponse = _context.sent;\n                _context.next = 10;\n                return self.getPosts(postargs);\n              case 10:\n                return _context.abrupt("return", ajaxResponse);\n              case 11:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function postItem(_x) {\n        return _postItem.apply(this, arguments);\n      }\n      return postItem;\n    }()\n  }, {\n    key: "checkMatch",\n    value: function checkMatch(question, searchText) {\n      var isMatch = false;\n      isMatch = question.content.toLowerCase().includes(searchText.toLowerCase());\n      if (isMatch) {\n        return isMatch;\n      }\n      for (var ii = 0; ii < question.answers.length; ++ii) {\n        isMatch = question.answers[ii].content.toLowerCase().includes(searchText.toLowerCase());\n        if (isMatch) {\n          break; //\n        }\n      }\n\n      return isMatch;\n    }\n  }, {\n    key: "getPosts",\n    value: function () {\n      var _getPosts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(postargs) {\n        var questions, reqData;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                questions = [];\n                reqData = postargs;\n                reqData.action = "helpie_qna_get_posts";\n                _context2.next = 5;\n                return jQuery.get(helpie_faq_object.ajax_url, reqData, function (response) {\n                  var posts = JSON.parse(response);\n                  console.log("Num of Posts: " + posts.length);\n                  console.log("getPosts: ");\n                  console.log(posts);\n                  posts.forEach(function (post) {\n                    var singleQuestion = {\n                      content: post.post_title,\n                      id: post.ID,\n                      answers: [],\n                      votes: post.votes,\n                      url: post.guid,\n                      currentUserVotes: post.current_user_votes,\n                      userHasAlreadyAnswered: post.user_has_already_answered\n                    };\n                    post["answers"].forEach(function (answer) {\n                      singleQuestion.answers.push({\n                        content: answer.comment_content,\n                        answer_by: answer.comment_author,\n                        created_date: answer.comment_date,\n                        comment_ID: answer.comment_ID,\n                        votes: answer.votes,\n                        human_time_diff: answer.human_time_diff\n                      });\n                    });\n\n                    // questions.push(singleQuestion);\n                    questions[questions.length] = singleQuestion;\n                  });\n                });\n              case 5:\n                this.setQuestions(questions);\n                // displayedQuestions = questions;\n                return _context2.abrupt("return", questions);\n              case 7:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function getPosts(_x2) {\n        return _getPosts.apply(this, arguments);\n      }\n      return getPosts;\n    }()\n  }]);\n  return Store;\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Store);\n\n//# sourceURL=webpack://helpie-faq/./assets/js/svelte/qna/store.js?')},"./assets/js/svelte/qna/storeInstances.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _store_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./store.js */ "./assets/js/svelte/qna/store.js");\n\nvar storeInstance = new _store_js__WEBPACK_IMPORTED_MODULE_0__["default"]();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (storeInstance);\n\n//# sourceURL=webpack://helpie-faq/./assets/js/svelte/qna/storeInstances.js?')},"./lib/stylus/js/search.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('var Tracker = __webpack_require__(/*! ../../../assets/js/components/insights/tracker */ "./assets/js/components/insights/tracker.js");\nvar ObjectSearch = __webpack_require__(/*! ../../../assets/js/components/faq/object_search.js */ "./assets/js/components/faq/object_search.js");\nvar FaqFunctions = __webpack_require__(/*! ../../../assets/js/components/faq/functions.js */ "./assets/js/components/faq/functions.js");\nvar FaqCollections = __webpack_require__(/*! ../../../assets/js/components/faq/collections.js */ "./assets/js/components/faq/collections.js");\nvar Pagination = __webpack_require__(/*! ../../../assets/js/components/faq/pagination.js */ "./assets/js/components/faq/pagination.js");\nvar selectors = {\n  accordions: ".helpie-faq.accordions",\n  faqSearch: ".helpie-faq .search__wrapper .search__input",\n  accordion: ".accordion",\n  accordionShow: "accordion--show",\n  accordionHide: "accordion--hide",\n  accordionHeading: ".accordion__heading",\n  accordionHeadingShow: "accordion__heading--show",\n  accordionHeadingHide: "accordion__heading--hide",\n  accordionHeader: ".accordion .accordion__item .accordion__header",\n  accordionItem: ".accordion__item",\n  accordionItemShow: "accordion__item--show",\n  accordionItemHide: "accordion__item--hide",\n  accordionBody: ".accordion__body",\n  searchMessage: ".search .search__message",\n  searchMessageContent: "<p class=\'search__message__content\'>" + faqStrings.noFaqsFound + "</p>"\n};\nvar Stylus = {\n  //setup before functions\n  searchTerm: "",\n  typingTimer: 0,\n  // timer identifier\n  doneTypingInterval: 2000,\n  // time in ms, 2 second for example\n  paginationEnabled: "0",\n  setSearchAttr: function setSearchAttr() {\n    /* Add \'search_attr\' to accordion headers */\n    jQuery(selectors.accordionHeader).each(function () {\n      var searchAttr = jQuery(this).text().toLowerCase();\n      jQuery(this).attr("data-search-term", searchAttr);\n    });\n  },\n  isContentMatch: function isContentMatch(element, searchTerm) {\n    var content = jQuery(element).find(selectors.accordionBody).text().toLowerCase();\n    if (content.indexOf(searchTerm) >= 0) return true;\n    return false;\n  },\n  isTitleMatch: function isTitleMatch(element, searchTerm) {\n    var content = jQuery(element).find(".accordion__header").attr("data-search-term");\n    if (content == undefined || content == "undefined") {\n      return false;\n    }\n    if (content.search(searchTerm) >= 0) {\n      return true;\n    }\n    return false;\n  },\n  isCategoryHeadingMatch: function isCategoryHeadingMatch(element, searchTerm) {\n    var content = jQuery(element).prev(selectors.accordionHeading).text().toLowerCase();\n    if (content.indexOf(searchTerm) >= 0) {\n      return true;\n    }\n    return false;\n  },\n  isCategroryAccordionMatch: function isCategroryAccordionMatch(element, searchTerm) {\n    if (jQuery(element).hasClass("accordion__category") == false) {\n      return false;\n    }\n    var thisModule = this;\n    return thisModule.isTitleMatch(element, searchTerm);\n  },\n  searchByAccordionItem: function searchByAccordionItem(element, props) {\n    var thisModule = this;\n    searchTerm = thisModule.searchTerm;\n    var titleMatch = thisModule.isTitleMatch(element, searchTerm);\n    var contentMatch = thisModule.isContentMatch(element, searchTerm);\n    //tags\n    var tagsMatch = thisModule.searchByTags(element, searchTerm);\n    var show = titleMatch || contentMatch || tagsMatch ? true : false;\n    thisModule.displayAccordionItem(element, show);\n    return show;\n  },\n  onSearchKeyup: function onSearchKeyup(that) {\n    var thisModule = this;\n    var searchTerm = thisModule.searchTerm;\n    console.log("*** onSearchKeyup() ***");\n    jQuery(that).closest(selectors.accordions).children(selectors.accordion).each(function () {\n      var $accordion = jQuery(this);\n      var showThatAccordion = false;\n      var categoryHeadingMatch = thisModule.isCategoryHeadingMatch($accordion, searchTerm);\n      if (categoryHeadingMatch == true) {\n        showThatAccordion = true;\n        thisModule.showAccordionSection($accordion, showThatAccordion);\n      } else {\n        $accordion.children(selectors.accordionItem).each(function () {\n          $accordionItem = jQuery(this);\n          var hasCategory = $accordionItem.hasClass("accordion__category");\n          console.log(" [hasCategory]: " + hasCategory);\n\n          // check the current accordion has a accordion__category class and match that accordion\n          var categoryMatched = thisModule.searchByCategory($accordionItem, searchTerm);\n\n          // let define a variable for use of show the current category with accordions, when hasCategory and categoryMatched variables are matched.\n          var showCategoryWithAccordions = hasCategory && categoryMatched ? true : false;\n\n          // let define a varible for want to search category inner accordions, if showCategoryWithAccordions var value as false\n          var searchCategoryInnerAccordions = showCategoryWithAccordions == false ? true : false;\n\n          // searching category inner accordions\n          var innerAccordionsContentMatched = false;\n          if (searchCategoryInnerAccordions) {\n            innerAccordionsContentMatched = thisModule.searchInnerAccordionsItems($accordionItem, searchTerm);\n          }\n\n          // let define a varible for searching normal accordion, if FAQ display mode as simple accordion\n\n          var searchSingleAccordionItem = hasCategory == false ? true : false;\n          var accordionMatched = false;\n          // find & show the accordion item\n          if (searchSingleAccordionItem) {\n            accordionMatched = thisModule.searchByAccordionItem($accordionItem, {});\n          }\n\n          // show the category with accordions\n          if (hasCategory && innerAccordionsContentMatched == false) {\n            thisModule.showCategoryWithAccordions($accordionItem, showCategoryWithAccordions);\n          }\n\n          // show the accordion with closest category accordion\n          if (searchCategoryInnerAccordions && innerAccordionsContentMatched) {\n            thisModule.showAccordionBelongsToCategory($accordionItem, true);\n          }\n          if (showThatAccordion == false) {\n            // show the closest accordion, if anyone category accordion text is matched.\n            if (showCategoryWithAccordions == true) {\n              showThatAccordion = true;\n            }\n\n            // show the closest accordion, if category inner accordions items title, content, or tags are matched\n            if (searchCategoryInnerAccordions == true && innerAccordionsContentMatched == true) {\n              showThatAccordion = true;\n            }\n\n            // show the accordion, if simple accordion matched.\n            if (searchSingleAccordionItem == true && accordionMatched == true) {\n              showThatAccordion = true;\n            }\n          }\n        });\n      }\n      thisModule.displayHeading($accordion, showThatAccordion);\n      thisModule.showAccordion($accordion, showThatAccordion);\n    });\n  },\n  searchByCategory: function searchByCategory($categoryAccordion, searchTerm) {\n    var thisModule = this;\n    var categoryAccordionMatched = thisModule.isCategroryAccordionMatch($categoryAccordion, searchTerm);\n    return categoryAccordionMatched;\n  },\n  searchInnerAccordionsItems: function searchInnerAccordionsItems($categoryAccordion, searchTerm) {\n    var thisModule = this;\n    var show = false;\n    // loop the current accordion and get inner accordions items.\n    $categoryAccordion.find(selectors.accordionItem).each(function () {\n      $item = jQuery(this);\n      var itemMatched = thisModule.searchByAccordionItem($item, {});\n      if (itemMatched == true) {\n        show = true;\n      }\n    });\n    return show;\n  },\n  init: function init() {\n    var thisModule = this;\n    console.log("Search init");\n    thisModule.setSearchAttr();\n    jQuery("body").on("keyup", selectors.faqSearch, function (event) {\n      var searchValue = jQuery(this).val().toLowerCase().replace(/[*+?^${}()|[\\]\\\\]/gi, "");\n      thisModule.searchTerm = searchValue;\n      var elementsObject = FaqFunctions.getElements(this);\n      thisModule.paginationEnabled = FaqFunctions.paginationEnabled(this);\n\n      // don\'t show the empty faqs block, if users entering the keywords for filtering faqs\n      thisModule.canSeeEmptyFAQsBlock(this, "hide");\n      if (thisModule.searchTerm == "" && thisModule.paginationEnabled == "1") {\n        jQuery(elementsObject.root).attr("data-search", "0");\n        thisModule.showAllAccordionsFromObject(this);\n        return false;\n      }\n      if (thisModule.searchTerm == "" && thisModule.paginationEnabled != "1") {\n        // show all faqs, if search term has an empty.\n        thisModule.showAllAccordions(this);\n        return false;\n      }\n\n      /***\r\n       * Note:- Should enable the pagination to the current shortcode (or) widgets\r\n       */\n      if (thisModule.paginationEnabled == "1") {\n        jQuery(elementsObject.root).attr("data-search", "1");\n        ObjectSearch.init(this, searchValue);\n      } else {\n        thisModule.onSearchKeyup(this);\n      }\n\n      // shown not found faq\'s content\n      thisModule.showEmptyFAQsContent(this);\n\n      // use of condition for avoid to tracking empty search term.\n      if (thisModule.searchTerm == "") {\n        return false;\n      }\n\n      // For ajaxCall, start the countdown\n      clearTimeout(thisModule.typingTimer);\n      thisModule.typingTimer = setTimeout(function () {\n        // donetyping() method\n        // For Tracking, searching Keywords\n        Tracker.searchCounter(thisModule.searchTerm);\n      }, thisModule.doneTypingInterval);\n    });\n  },\n  showAllAccordions: function showAllAccordions(that) {\n    var thisModule = this;\n    var canDisplay = true;\n    jQuery(that).closest(selectors.accordions).children(selectors.accordion).each(function () {\n      var $accordion = jQuery(this);\n\n      //show accordion\n      thisModule.showAccordion($accordion, canDisplay);\n\n      //show heading\n      thisModule.displayHeading($accordion, canDisplay);\n\n      // show inner accordion\n      $accordion.find(selectors.accordion).removeClass(selectors.accordionHide).addClass(selectors.accordionShow);\n\n      //show accordion items\n      $accordion.find(selectors.accordionItem).removeClass(selectors.accordionItemHide).addClass(selectors.accordionItemShow);\n    });\n  },\n  showEmptyFAQsContent: function showEmptyFAQsContent(that) {\n    var thisModule = this;\n    var hiddenFaqsCount = 0;\n    var totalFaqsCount = jQuery(that).closest(selectors.accordions).find(selectors.accordionItem).length;\n    jQuery(that).closest(selectors.accordions).find(selectors.accordionItem).each(function () {\n      // count all hidden faqs\n      if (jQuery(this).is(":visible") == false) {\n        hiddenFaqsCount = parseInt(hiddenFaqsCount) + 1;\n      }\n    });\n\n    // check hidden faqs-count with overall faq-count, return if not match both counts.\n    if (hiddenFaqsCount != totalFaqsCount) {\n      return;\n    }\n    jQuery(that).closest(selectors.accordions).find(selectors.accordion).each(function () {\n      var $accordion = jQuery(this);\n      thisModule.displayHeading($accordion, false);\n      thisModule.showAccordion($accordion, false);\n    });\n\n    // append & show the not found faq text block\n    jQuery(that).closest(selectors.accordions).find(selectors.searchMessage).empty().show().append(selectors.searchMessageContent);\n  },\n  canSeeEmptyFAQsBlock: function canSeeEmptyFAQsBlock(that, status) {\n    var canSeeElement = "none";\n    if (status == "show") {\n      canSeeElement = "block";\n    }\n    jQuery(that).closest(selectors.accordions).find(selectors.searchMessage).css("display", canSeeElement);\n  },\n  displayAccordionItem: function displayAccordionItem(event, canDisplay) {\n    var addClassName = canDisplay == true ? selectors.accordionItemShow : selectors.accordionItemHide;\n    var removeClassName = canDisplay == false ? selectors.accordionItemShow : selectors.accordionItemHide;\n    event.removeClass(removeClassName).addClass(addClassName);\n  },\n  displayHeading: function displayHeading(event, canDisplay) {\n    var addClassName = canDisplay == true ? selectors.accordionHeadingShow : selectors.accordionHeadingHide;\n    var removeClassName = canDisplay == false ? selectors.accordionHeadingShow : selectors.accordionHeadingHide;\n    event.prev(selectors.accordionHeading).removeClass(removeClassName).addClass(addClassName);\n  },\n  showCategoryAccordions: function showCategoryAccordions(element, canDisplay) {\n    var addClassName = canDisplay == true ? selectors.accordionItemShow : selectors.accordionItemHide;\n    var removeClassName = canDisplay == false ? selectors.accordionItemShow : selectors.accordionItemHide;\n    jQuery(element).find(selectors.accordionItem).removeClass(removeClassName).addClass(addClassName);\n  },\n  showAccordionSection: function showAccordionSection(element, canDisplay) {\n    var thisModule = this;\n    thisModule.displayHeading(element, canDisplay);\n    thisModule.showCategoryAccordions(element, canDisplay);\n    thisModule.showAccordion(element, canDisplay);\n  },\n  showAccordion: function showAccordion(element, canDisplay) {\n    var addClassName = canDisplay == true ? selectors.accordionShow : selectors.accordionHide;\n    var removeClassName = canDisplay == false ? selectors.accordionShow : selectors.accordionHide;\n    jQuery(element).removeClass(removeClassName).addClass(addClassName);\n  },\n  showCategoryWithAccordions: function showCategoryWithAccordions(element, canDisplay) {\n    var thisModule = this;\n    thisModule.displayAccordionItem(element, canDisplay);\n    thisModule.showCategoryAccordions(element, canDisplay);\n    thisModule.showAccordion(element, canDisplay);\n  },\n  showAccordionBelongsToCategory: function showAccordionBelongsToCategory(element, canDisplay) {\n    var thisModule = this;\n    jQuery(element).find(selectors.accordion).removeClass(selectors.accordionHide).addClass(selectors.accordionShow);\n    thisModule.displayAccordionItem(element, canDisplay);\n  },\n  searchByTags: function searchByTags(element, searchTerm) {\n    var tags = jQuery(element).find(".accordion__header").attr("data-tags");\n    var foundTag = false;\n    if (tags == undefined || tags == "undefined" || tags.length == 0) {\n      return foundTag;\n    }\n    tags.split(",").forEach(function (tag) {\n      tag = tag.toLowerCase();\n      if (tag.search(searchTerm) != -1) {\n        foundTag = true;\n      }\n    });\n    return foundTag;\n  },\n  showAllAccordionsFromObject: function showAllAccordionsFromObject(element) {\n    var elementsObject = FaqFunctions.getElements(element);\n    var currenPageNo = FaqFunctions.getPaginationCurrentPage(elementsObject);\n    var shortcodeIndex = FaqFunctions.getShortcodeIndex(elementsObject);\n    var paginateData = {\n      page: currenPageNo\n    };\n    var viewProps = FaqCollections.getCurrentShortcodeViewProps(shortcodeIndex);\n    var totalNoOfPage = FaqCollections.getTotalNoOfPages(viewProps);\n    var thisPageViewProps = FaqCollections.getCurrentPageViewProps(paginateData, {\n      collection: viewProps.collection,\n      items: viewProps.items\n    });\n    FaqFunctions.appendFaqsContent(elementsObject, thisPageViewProps);\n    Pagination.renderPageLinks(elementsObject.pagination, {\n      current: currenPageNo,\n      last: totalNoOfPage\n    });\n  }\n};\nmodule.exports = Stylus;\n\n//# sourceURL=webpack://helpie-faq/./lib/stylus/js/search.js?')},"./assets/css/main.scss":()=>{"use strict";eval("// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://helpie-faq/./assets/css/main.scss?")},"./assets/js/svelte/qna/qna.svelte.1.css!=!./node_modules/svelte-loader/index.js?cssPath=C:/Users/admin/Local Sites/helpie-faq/app/public/wp-content/plugins/helpie-faq/assets/js/svelte/qna/qna.svelte.1.css!./assets/js/svelte/qna/qna.svelte":()=>{"use strict";eval("// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://helpie-faq/./assets/js/svelte/qna/qna.svelte?./assets/js/svelte/qna/qna.svelte.1.css!=!./node_modules/svelte-loader/index.js?cssPath=C:/Users/admin/Local_Sites/helpie-faq/app/public/wp-content/plugins/helpie-faq/assets/js/svelte/qna/qna.svelte.1.css")},"./assets/js/svelte/qna/showMore.svelte.5.css!=!./node_modules/svelte-loader/index.js?cssPath=C:/Users/admin/Local Sites/helpie-faq/app/public/wp-content/plugins/helpie-faq/assets/js/svelte/qna/showMore.svelte.5.css!./assets/js/svelte/qna/showMore.svelte":()=>{"use strict";eval("// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://helpie-faq/./assets/js/svelte/qna/showMore.svelte?./assets/js/svelte/qna/showMore.svelte.5.css!=!./node_modules/svelte-loader/index.js?cssPath=C:/Users/admin/Local_Sites/helpie-faq/app/public/wp-content/plugins/helpie-faq/assets/js/svelte/qna/showMore.svelte.5.css")},"./assets/js/svelte/qna/submitForm.svelte.4.css!=!./node_modules/svelte-loader/index.js?cssPath=C:/Users/admin/Local Sites/helpie-faq/app/public/wp-content/plugins/helpie-faq/assets/js/svelte/qna/submitForm.svelte.4.css!./assets/js/svelte/qna/submitForm.svelte":()=>{"use strict";eval("// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://helpie-faq/./assets/js/svelte/qna/submitForm.svelte?./assets/js/svelte/qna/submitForm.svelte.4.css!=!./node_modules/svelte-loader/index.js?cssPath=C:/Users/admin/Local_Sites/helpie-faq/app/public/wp-content/plugins/helpie-faq/assets/js/svelte/qna/submitForm.svelte.4.css")},"./assets/js/svelte/qna/listItem.svelte":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");\n/* assets\\js\\svelte\\qna\\listItem.svelte generated by Svelte v3.52.0 */\n\n\nconst file = "assets\\\\js\\\\svelte\\\\qna\\\\listItem.svelte";\n\n// (12:2) {#if id == "previous" && icon}\nfunction create_if_block_1(ctx) {\n\tlet span;\n\tlet span_class_value;\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tspan = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span, "class", span_class_value = "dashicons dashicons-" + /*icon*/ ctx[2]);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span, file, 12, 3, 340);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, span, anchor);\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tif (dirty & /*icon*/ 4 && span_class_value !== (span_class_value = "dashicons dashicons-" + /*icon*/ ctx[2])) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span, "class", span_class_value);\n\t\t\t}\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(span);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block_1.name,\n\t\ttype: "if",\n\t\tsource: "(12:2) {#if id == \\\\\\"previous\\\\\\" && icon}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (16:2) {#if id == "next" && icon}\nfunction create_if_block(ctx) {\n\tlet span;\n\tlet span_class_value;\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tspan = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span, "class", span_class_value = "dashicons dashicons-" + /*icon*/ ctx[2]);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span, file, 16, 3, 438);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, span, anchor);\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tif (dirty & /*icon*/ 4 && span_class_value !== (span_class_value = "dashicons dashicons-" + /*icon*/ ctx[2])) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span, "class", span_class_value);\n\t\t\t}\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(span);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block.name,\n\t\ttype: "if",\n\t\tsource: "(16:2) {#if id == \\\\\\"next\\\\\\" && icon}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\nfunction create_fragment(ctx) {\n\tlet li;\n\tlet a;\n\tlet t0;\n\tlet t1;\n\tlet t2;\n\tlet li_class_value;\n\tlet mounted;\n\tlet dispose;\n\tlet if_block0 = /*id*/ ctx[0] == "previous" && /*icon*/ ctx[2] && create_if_block_1(ctx);\n\tlet if_block1 = /*id*/ ctx[0] == "next" && /*icon*/ ctx[2] && create_if_block(ctx);\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tli = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("li");\n\t\t\ta = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("a");\n\t\t\tif (if_block0) if_block0.c();\n\t\t\tt0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tt1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(/*label*/ ctx[1]);\n\t\t\tt2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tif (if_block1) if_block1.c();\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a, "disabled", /*readOnly*/ ctx[4]);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(a, "active", /*active*/ ctx[3]);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(a, file, 10, 1, 235);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(li, "class", li_class_value = "tablesome-pagination__" + /*id*/ ctx[0] + " pagination-" + /*id*/ ctx[0]);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(li, file, 9, 0, 177);\n\t\t},\n\t\tl: function claim(nodes) {\n\t\t\tthrow new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, li, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(li, a);\n\t\t\tif (if_block0) if_block0.m(a, null);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(a, t0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(a, t1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(a, t2);\n\t\t\tif (if_block1) if_block1.m(a, null);\n\n\t\t\tif (!mounted) {\n\t\t\t\tdispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(a, "click", /*click_handler*/ ctx[6], false, false, false);\n\t\t\t\tmounted = true;\n\t\t\t}\n\t\t},\n\t\tp: function update(ctx, [dirty]) {\n\t\t\tif (/*id*/ ctx[0] == "previous" && /*icon*/ ctx[2]) {\n\t\t\t\tif (if_block0) {\n\t\t\t\t\tif_block0.p(ctx, dirty);\n\t\t\t\t} else {\n\t\t\t\t\tif_block0 = create_if_block_1(ctx);\n\t\t\t\t\tif_block0.c();\n\t\t\t\t\tif_block0.m(a, t0);\n\t\t\t\t}\n\t\t\t} else if (if_block0) {\n\t\t\t\tif_block0.d(1);\n\t\t\t\tif_block0 = null;\n\t\t\t}\n\n\t\t\tif (dirty & /*label*/ 2) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t1, /*label*/ ctx[1]);\n\n\t\t\tif (/*id*/ ctx[0] == "next" && /*icon*/ ctx[2]) {\n\t\t\t\tif (if_block1) {\n\t\t\t\t\tif_block1.p(ctx, dirty);\n\t\t\t\t} else {\n\t\t\t\t\tif_block1 = create_if_block(ctx);\n\t\t\t\t\tif_block1.c();\n\t\t\t\t\tif_block1.m(a, null);\n\t\t\t\t}\n\t\t\t} else if (if_block1) {\n\t\t\t\tif_block1.d(1);\n\t\t\t\tif_block1 = null;\n\t\t\t}\n\n\t\t\tif (dirty & /*readOnly*/ 16) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a, "disabled", /*readOnly*/ ctx[4]);\n\t\t\t}\n\n\t\t\tif (dirty & /*active*/ 8) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.toggle_class)(a, "active", /*active*/ ctx[3]);\n\t\t\t}\n\n\t\t\tif (dirty & /*id*/ 1 && li_class_value !== (li_class_value = "tablesome-pagination__" + /*id*/ ctx[0] + " pagination-" + /*id*/ ctx[0])) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(li, "class", li_class_value);\n\t\t\t}\n\t\t},\n\t\ti: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\to: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\td: function destroy(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(li);\n\t\t\tif (if_block0) if_block0.d();\n\t\t\tif (if_block1) if_block1.d();\n\t\t\tmounted = false;\n\t\t\tdispose();\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_fragment.name,\n\t\ttype: "component",\n\t\tsource: "",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n\tlet { $$slots: slots = {}, $$scope } = $$props;\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)(\'ListItem\', slots, []);\n\tlet { id } = $$props;\n\tlet { label = "" } = $$props;\n\tlet { icon = "" } = $$props;\n\tlet { active = false } = $$props;\n\tlet { readOnly = false } = $$props;\n\tlet { callback = "" } = $$props;\n\n\t$$self.$$.on_mount.push(function () {\n\t\tif (id === undefined && !(\'id\' in $$props || $$self.$$.bound[$$self.$$.props[\'id\']])) {\n\t\t\tconsole.warn("<ListItem> was created without expected prop \'id\'");\n\t\t}\n\t});\n\n\tconst writable_props = [\'id\', \'label\', \'icon\', \'active\', \'readOnly\', \'callback\'];\n\n\tObject.keys($$props).forEach(key => {\n\t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== \'$$\' && key !== \'slot\') console.warn(`<ListItem> was created with unknown prop \'${key}\'`);\n\t});\n\n\tconst click_handler = () => callback(id);\n\n\t$$self.$$set = $$props => {\n\t\tif (\'id\' in $$props) $$invalidate(0, id = $$props.id);\n\t\tif (\'label\' in $$props) $$invalidate(1, label = $$props.label);\n\t\tif (\'icon\' in $$props) $$invalidate(2, icon = $$props.icon);\n\t\tif (\'active\' in $$props) $$invalidate(3, active = $$props.active);\n\t\tif (\'readOnly\' in $$props) $$invalidate(4, readOnly = $$props.readOnly);\n\t\tif (\'callback\' in $$props) $$invalidate(5, callback = $$props.callback);\n\t};\n\n\t$$self.$capture_state = () => ({\n\t\tid,\n\t\tlabel,\n\t\ticon,\n\t\tactive,\n\t\treadOnly,\n\t\tcallback\n\t});\n\n\t$$self.$inject_state = $$props => {\n\t\tif (\'id\' in $$props) $$invalidate(0, id = $$props.id);\n\t\tif (\'label\' in $$props) $$invalidate(1, label = $$props.label);\n\t\tif (\'icon\' in $$props) $$invalidate(2, icon = $$props.icon);\n\t\tif (\'active\' in $$props) $$invalidate(3, active = $$props.active);\n\t\tif (\'readOnly\' in $$props) $$invalidate(4, readOnly = $$props.readOnly);\n\t\tif (\'callback\' in $$props) $$invalidate(5, callback = $$props.callback);\n\t};\n\n\tif ($$props && "$$inject" in $$props) {\n\t\t$$self.$inject_state($$props.$$inject);\n\t}\n\n\treturn [id, label, icon, active, readOnly, callback, click_handler];\n}\n\nclass ListItem extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {\n\tconstructor(options) {\n\t\tsuper(options);\n\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {\n\t\t\tid: 0,\n\t\t\tlabel: 1,\n\t\t\ticon: 2,\n\t\t\tactive: 3,\n\t\t\treadOnly: 4,\n\t\t\tcallback: 5\n\t\t});\n\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {\n\t\t\tcomponent: this,\n\t\t\ttagName: "ListItem",\n\t\t\toptions,\n\t\t\tid: create_fragment.name\n\t\t});\n\t}\n\n\tget id() {\n\t\tthrow new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset id(value) {\n\t\tthrow new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tget label() {\n\t\tthrow new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset label(value) {\n\t\tthrow new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tget icon() {\n\t\tthrow new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset icon(value) {\n\t\tthrow new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tget active() {\n\t\tthrow new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset active(value) {\n\t\tthrow new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tget readOnly() {\n\t\tthrow new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset readOnly(value) {\n\t\tthrow new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tget callback() {\n\t\tthrow new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset callback(value) {\n\t\tthrow new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ListItem);\n\n//# sourceURL=webpack://helpie-faq/./assets/js/svelte/qna/listItem.svelte?')},"./assets/js/svelte/qna/pagination.svelte":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");\n/* harmony import */ var _listItem_svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./listItem.svelte */ "./assets/js/svelte/qna/listItem.svelte");\n/* harmony import */ var svelte_store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte/store */ "./node_modules/svelte/store/index.mjs");\n/* assets\\js\\svelte\\qna\\pagination.svelte generated by Svelte v3.52.0 */\n\n\nconst { console: console_1, window: window_1 } = svelte_internal__WEBPACK_IMPORTED_MODULE_0__.globals;\n\n\nconst file = "assets\\\\js\\\\svelte\\\\qna\\\\pagination.svelte";\n\nfunction get_each_context(ctx, list, i) {\n\tconst child_ctx = ctx.slice();\n\tchild_ctx[16] = list[i];\n\treturn child_ctx;\n}\n\n// (146:0) {#if 1 < numOfTotalPages}\nfunction create_if_block(ctx) {\n\tlet nav;\n\tlet ul;\n\tlet show_if_4 = /*showFirstAndLastButtons*/ ctx[7](/*innerWidth*/ ctx[0]);\n\tlet t0;\n\tlet show_if_3 = /*showPreviousAndNextButtons*/ ctx[8](/*innerWidth*/ ctx[0]);\n\tlet t1;\n\tlet show_if_2 = /*showNumberButtons*/ ctx[9](/*innerWidth*/ ctx[0]);\n\tlet t2;\n\tlet show_if_1 = /*showPreviousAndNextButtons*/ ctx[8](/*innerWidth*/ ctx[0]);\n\tlet t3;\n\tlet show_if = /*showFirstAndLastButtons*/ ctx[7](/*innerWidth*/ ctx[0]);\n\tlet current;\n\tlet if_block0 = show_if_4 && create_if_block_6(ctx);\n\tlet if_block1 = show_if_3 && create_if_block_5(ctx);\n\tlet if_block2 = show_if_2 && create_if_block_3(ctx);\n\tlet if_block3 = show_if_1 && create_if_block_2(ctx);\n\tlet if_block4 = show_if && create_if_block_1(ctx);\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tnav = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("nav");\n\t\t\tul = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("ul");\n\t\t\tif (if_block0) if_block0.c();\n\t\t\tt0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tif (if_block1) if_block1.c();\n\t\t\tt1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tif (if_block2) if_block2.c();\n\t\t\tt2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tif (if_block3) if_block3.c();\n\t\t\tt3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tif (if_block4) if_block4.c();\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(ul, file, 147, 2, 3222);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(nav, "role", "pagination");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(nav, "class", "helpiefaq__qna-pagination pagination");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(nav, file, 146, 1, 3150);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, nav, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(nav, ul);\n\t\t\tif (if_block0) if_block0.m(ul, null);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(ul, t0);\n\t\t\tif (if_block1) if_block1.m(ul, null);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(ul, t1);\n\t\t\tif (if_block2) if_block2.m(ul, null);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(ul, t2);\n\t\t\tif (if_block3) if_block3.m(ul, null);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(ul, t3);\n\t\t\tif (if_block4) if_block4.m(ul, null);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tif (dirty & /*innerWidth*/ 1) show_if_4 = /*showFirstAndLastButtons*/ ctx[7](/*innerWidth*/ ctx[0]);\n\n\t\t\tif (show_if_4) {\n\t\t\t\tif (if_block0) {\n\t\t\t\t\tif_block0.p(ctx, dirty);\n\n\t\t\t\t\tif (dirty & /*innerWidth*/ 1) {\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif_block0 = create_if_block_6(ctx);\n\t\t\t\t\tif_block0.c();\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);\n\t\t\t\t\tif_block0.m(ul, t0);\n\t\t\t\t}\n\t\t\t} else if (if_block0) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0, 1, 1, () => {\n\t\t\t\t\tif_block0 = null;\n\t\t\t\t});\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t}\n\n\t\t\tif (dirty & /*innerWidth*/ 1) show_if_3 = /*showPreviousAndNextButtons*/ ctx[8](/*innerWidth*/ ctx[0]);\n\n\t\t\tif (show_if_3) {\n\t\t\t\tif (if_block1) {\n\t\t\t\t\tif_block1.p(ctx, dirty);\n\n\t\t\t\t\tif (dirty & /*innerWidth*/ 1) {\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1, 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif_block1 = create_if_block_5(ctx);\n\t\t\t\t\tif_block1.c();\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1, 1);\n\t\t\t\t\tif_block1.m(ul, t1);\n\t\t\t\t}\n\t\t\t} else if (if_block1) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block1, 1, 1, () => {\n\t\t\t\t\tif_block1 = null;\n\t\t\t\t});\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t}\n\n\t\t\tif (dirty & /*innerWidth*/ 1) show_if_2 = /*showNumberButtons*/ ctx[9](/*innerWidth*/ ctx[0]);\n\n\t\t\tif (show_if_2) {\n\t\t\t\tif (if_block2) {\n\t\t\t\t\tif_block2.p(ctx, dirty);\n\n\t\t\t\t\tif (dirty & /*innerWidth*/ 1) {\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block2, 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif_block2 = create_if_block_3(ctx);\n\t\t\t\t\tif_block2.c();\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block2, 1);\n\t\t\t\t\tif_block2.m(ul, t2);\n\t\t\t\t}\n\t\t\t} else if (if_block2) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block2, 1, 1, () => {\n\t\t\t\t\tif_block2 = null;\n\t\t\t\t});\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t}\n\n\t\t\tif (dirty & /*innerWidth*/ 1) show_if_1 = /*showPreviousAndNextButtons*/ ctx[8](/*innerWidth*/ ctx[0]);\n\n\t\t\tif (show_if_1) {\n\t\t\t\tif (if_block3) {\n\t\t\t\t\tif_block3.p(ctx, dirty);\n\n\t\t\t\t\tif (dirty & /*innerWidth*/ 1) {\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block3, 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif_block3 = create_if_block_2(ctx);\n\t\t\t\t\tif_block3.c();\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block3, 1);\n\t\t\t\t\tif_block3.m(ul, t3);\n\t\t\t\t}\n\t\t\t} else if (if_block3) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block3, 1, 1, () => {\n\t\t\t\t\tif_block3 = null;\n\t\t\t\t});\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t}\n\n\t\t\tif (dirty & /*innerWidth*/ 1) show_if = /*showFirstAndLastButtons*/ ctx[7](/*innerWidth*/ ctx[0]);\n\n\t\t\tif (show_if) {\n\t\t\t\tif (if_block4) {\n\t\t\t\t\tif_block4.p(ctx, dirty);\n\n\t\t\t\t\tif (dirty & /*innerWidth*/ 1) {\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block4, 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif_block4 = create_if_block_1(ctx);\n\t\t\t\t\tif_block4.c();\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block4, 1);\n\t\t\t\t\tif_block4.m(ul, null);\n\t\t\t\t}\n\t\t\t} else if (if_block4) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block4, 1, 1, () => {\n\t\t\t\t\tif_block4 = null;\n\t\t\t\t});\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t}\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block2);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block3);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block4);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block2);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block3);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block4);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(nav);\n\t\t\tif (if_block0) if_block0.d();\n\t\t\tif (if_block1) if_block1.d();\n\t\t\tif (if_block2) if_block2.d();\n\t\t\tif (if_block3) if_block3.d();\n\t\t\tif (if_block4) if_block4.d();\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block.name,\n\t\ttype: "if",\n\t\tsource: "(146:0) {#if 1 < numOfTotalPages}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (149:3) {#if showFirstAndLastButtons(innerWidth)}\nfunction create_if_block_6(ctx) {\n\tlet listitem;\n\tlet current;\n\n\tlistitem = new _listItem_svelte__WEBPACK_IMPORTED_MODULE_1__["default"]({\n\t\t\tprops: {\n\t\t\t\tid: "first",\n\t\t\t\tlabel: /*labels*/ ctx[4].first,\n\t\t\t\treadOnly: /*currentPage*/ ctx[1] === 0,\n\t\t\t\tcallback: /*onChange*/ ctx[5]\n\t\t\t},\n\t\t\t$$inline: true\n\t\t});\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(listitem.$$.fragment);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(listitem, target, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tconst listitem_changes = {};\n\t\t\tif (dirty & /*currentPage*/ 2) listitem_changes.readOnly = /*currentPage*/ ctx[1] === 0;\n\t\t\tlistitem.$set(listitem_changes);\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(listitem.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(listitem.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(listitem, detaching);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block_6.name,\n\t\ttype: "if",\n\t\tsource: "(149:3) {#if showFirstAndLastButtons(innerWidth)}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (158:3) {#if showPreviousAndNextButtons(innerWidth)}\nfunction create_if_block_5(ctx) {\n\tlet listitem;\n\tlet current;\n\n\tlistitem = new _listItem_svelte__WEBPACK_IMPORTED_MODULE_1__["default"]({\n\t\t\tprops: {\n\t\t\t\tid: "previous",\n\t\t\t\tlabel: /*labels*/ ctx[4].previous,\n\t\t\t\ticon: /*isMobileScreen*/ ctx[6](/*innerWidth*/ ctx[0])\n\t\t\t\t? "arrow-left-alt2"\n\t\t\t\t: "",\n\t\t\t\treadOnly: /*currentPage*/ ctx[1] === 0,\n\t\t\t\tcallback: /*onChange*/ ctx[5]\n\t\t\t},\n\t\t\t$$inline: true\n\t\t});\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(listitem.$$.fragment);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(listitem, target, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tconst listitem_changes = {};\n\n\t\t\tif (dirty & /*innerWidth*/ 1) listitem_changes.icon = /*isMobileScreen*/ ctx[6](/*innerWidth*/ ctx[0])\n\t\t\t? "arrow-left-alt2"\n\t\t\t: "";\n\n\t\t\tif (dirty & /*currentPage*/ 2) listitem_changes.readOnly = /*currentPage*/ ctx[1] === 0;\n\t\t\tlistitem.$set(listitem_changes);\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(listitem.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(listitem.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(listitem, detaching);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block_5.name,\n\t\ttype: "if",\n\t\tsource: "(158:3) {#if showPreviousAndNextButtons(innerWidth)}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (168:3) {#if showNumberButtons(innerWidth)}\nfunction create_if_block_3(ctx) {\n\tlet each_1_anchor;\n\tlet current;\n\tlet each_value = /*buttons*/ ctx[3];\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);\n\tlet each_blocks = [];\n\n\tfor (let i = 0; i < each_value.length; i += 1) {\n\t\teach_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n\t}\n\n\tconst out = i => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[i], 1, 1, () => {\n\t\teach_blocks[i] = null;\n\t});\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n\t\t\t\teach_blocks[i].c();\n\t\t\t}\n\n\t\t\teach_1_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n\t\t\t\teach_blocks[i].m(target, anchor);\n\t\t\t}\n\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, each_1_anchor, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tif (dirty & /*currentPage, buttons, onChange, numOfTotalPages*/ 46) {\n\t\t\t\teach_value = /*buttons*/ ctx[3];\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);\n\t\t\t\tlet i;\n\n\t\t\t\tfor (i = 0; i < each_value.length; i += 1) {\n\t\t\t\t\tconst child_ctx = get_each_context(ctx, each_value, i);\n\n\t\t\t\t\tif (each_blocks[i]) {\n\t\t\t\t\t\teach_blocks[i].p(child_ctx, dirty);\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i], 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teach_blocks[i] = create_each_block(child_ctx);\n\t\t\t\t\t\teach_blocks[i].c();\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i], 1);\n\t\t\t\t\t\teach_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\tfor (i = each_value.length; i < each_blocks.length; i += 1) {\n\t\t\t\t\tout(i);\n\t\t\t\t}\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t}\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\n\t\t\tfor (let i = 0; i < each_value.length; i += 1) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i]);\n\t\t\t}\n\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\teach_blocks = each_blocks.filter(Boolean);\n\n\t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[i]);\n\t\t\t}\n\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_each)(each_blocks, detaching);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(each_1_anchor);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block_3.name,\n\t\ttype: "if",\n\t\tsource: "(168:3) {#if showNumberButtons(innerWidth)}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (170:5) {#if currentPage + button >= 0 && currentPage + button < numOfTotalPages}\nfunction create_if_block_4(ctx) {\n\tlet listitem;\n\tlet current;\n\n\tlistitem = new _listItem_svelte__WEBPACK_IMPORTED_MODULE_1__["default"]({\n\t\t\tprops: {\n\t\t\t\tid: "page-" + (/*currentPage*/ ctx[1] + /*button*/ ctx[16]),\n\t\t\t\tlabel: /*currentPage*/ ctx[1] + /*button*/ ctx[16] + 1,\n\t\t\t\tactive: /*currentPage*/ ctx[1] === /*currentPage*/ ctx[1] + /*button*/ ctx[16],\n\t\t\t\tcallback: /*onChange*/ ctx[5]\n\t\t\t},\n\t\t\t$$inline: true\n\t\t});\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(listitem.$$.fragment);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(listitem, target, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tconst listitem_changes = {};\n\t\t\tif (dirty & /*currentPage*/ 2) listitem_changes.id = "page-" + (/*currentPage*/ ctx[1] + /*button*/ ctx[16]);\n\t\t\tif (dirty & /*currentPage*/ 2) listitem_changes.label = /*currentPage*/ ctx[1] + /*button*/ ctx[16] + 1;\n\t\t\tif (dirty & /*currentPage*/ 2) listitem_changes.active = /*currentPage*/ ctx[1] === /*currentPage*/ ctx[1] + /*button*/ ctx[16];\n\t\t\tlistitem.$set(listitem_changes);\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(listitem.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(listitem.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(listitem, detaching);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block_4.name,\n\t\ttype: "if",\n\t\tsource: "(170:5) {#if currentPage + button >= 0 && currentPage + button < numOfTotalPages}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (169:4) {#each buttons as button}\nfunction create_each_block(ctx) {\n\tlet if_block_anchor;\n\tlet current;\n\tlet if_block = /*currentPage*/ ctx[1] + /*button*/ ctx[16] >= 0 && /*currentPage*/ ctx[1] + /*button*/ ctx[16] < /*numOfTotalPages*/ ctx[2] && create_if_block_4(ctx);\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tif (if_block) if_block.c();\n\t\t\tif_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\tif (if_block) if_block.m(target, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tif (/*currentPage*/ ctx[1] + /*button*/ ctx[16] >= 0 && /*currentPage*/ ctx[1] + /*button*/ ctx[16] < /*numOfTotalPages*/ ctx[2]) {\n\t\t\t\tif (if_block) {\n\t\t\t\t\tif_block.p(ctx, dirty);\n\n\t\t\t\t\tif (dirty & /*currentPage, numOfTotalPages*/ 6) {\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif_block = create_if_block_4(ctx);\n\t\t\t\t\tif_block.c();\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);\n\t\t\t\t\tif_block.m(if_block_anchor.parentNode, if_block_anchor);\n\t\t\t\t}\n\t\t\t} else if (if_block) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block, 1, 1, () => {\n\t\t\t\t\tif_block = null;\n\t\t\t\t});\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t}\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\tif (if_block) if_block.d(detaching);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_each_block.name,\n\t\ttype: "each",\n\t\tsource: "(169:4) {#each buttons as button}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (181:3) {#if showPreviousAndNextButtons(innerWidth)}\nfunction create_if_block_2(ctx) {\n\tlet listitem;\n\tlet current;\n\n\tlistitem = new _listItem_svelte__WEBPACK_IMPORTED_MODULE_1__["default"]({\n\t\t\tprops: {\n\t\t\t\tid: "next",\n\t\t\t\tlabel: /*labels*/ ctx[4].next,\n\t\t\t\ticon: /*isMobileScreen*/ ctx[6](/*innerWidth*/ ctx[0])\n\t\t\t\t? "arrow-right-alt2"\n\t\t\t\t: "",\n\t\t\t\treadOnly: /*currentPage*/ ctx[1] > /*numOfTotalPages*/ ctx[2] - 1,\n\t\t\t\tcallback: /*onChange*/ ctx[5]\n\t\t\t},\n\t\t\t$$inline: true\n\t\t});\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(listitem.$$.fragment);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(listitem, target, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tconst listitem_changes = {};\n\n\t\t\tif (dirty & /*innerWidth*/ 1) listitem_changes.icon = /*isMobileScreen*/ ctx[6](/*innerWidth*/ ctx[0])\n\t\t\t? "arrow-right-alt2"\n\t\t\t: "";\n\n\t\t\tif (dirty & /*currentPage, numOfTotalPages*/ 6) listitem_changes.readOnly = /*currentPage*/ ctx[1] > /*numOfTotalPages*/ ctx[2] - 1;\n\t\t\tlistitem.$set(listitem_changes);\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(listitem.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(listitem.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(listitem, detaching);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block_2.name,\n\t\ttype: "if",\n\t\tsource: "(181:3) {#if showPreviousAndNextButtons(innerWidth)}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (190:3) {#if showFirstAndLastButtons(innerWidth)}\nfunction create_if_block_1(ctx) {\n\tlet listitem;\n\tlet current;\n\n\tlistitem = new _listItem_svelte__WEBPACK_IMPORTED_MODULE_1__["default"]({\n\t\t\tprops: {\n\t\t\t\tid: "last",\n\t\t\t\tlabel: /*labels*/ ctx[4].last,\n\t\t\t\treadOnly: /*currentPage*/ ctx[1] >= /*numOfTotalPages*/ ctx[2],\n\t\t\t\tcallback: /*onChange*/ ctx[5]\n\t\t\t},\n\t\t\t$$inline: true\n\t\t});\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(listitem.$$.fragment);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(listitem, target, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tconst listitem_changes = {};\n\t\t\tif (dirty & /*currentPage, numOfTotalPages*/ 6) listitem_changes.readOnly = /*currentPage*/ ctx[1] >= /*numOfTotalPages*/ ctx[2];\n\t\t\tlistitem.$set(listitem_changes);\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(listitem.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(listitem.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(listitem, detaching);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block_1.name,\n\t\ttype: "if",\n\t\tsource: "(190:3) {#if showFirstAndLastButtons(innerWidth)}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\nfunction create_fragment(ctx) {\n\tlet if_block_anchor;\n\tlet current;\n\tlet mounted;\n\tlet dispose;\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(/*onwindowresize*/ ctx[12]);\n\tlet if_block = 1 < /*numOfTotalPages*/ ctx[2] && create_if_block(ctx);\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tif (if_block) if_block.c();\n\t\t\tif_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();\n\t\t},\n\t\tl: function claim(nodes) {\n\t\t\tthrow new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\tif (if_block) if_block.m(target, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);\n\t\t\tcurrent = true;\n\n\t\t\tif (!mounted) {\n\t\t\t\tdispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(window_1, "resize", /*onwindowresize*/ ctx[12]);\n\t\t\t\tmounted = true;\n\t\t\t}\n\t\t},\n\t\tp: function update(ctx, [dirty]) {\n\t\t\tif (1 < /*numOfTotalPages*/ ctx[2]) {\n\t\t\t\tif (if_block) {\n\t\t\t\t\tif_block.p(ctx, dirty);\n\n\t\t\t\t\tif (dirty & /*numOfTotalPages*/ 4) {\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif_block = create_if_block(ctx);\n\t\t\t\t\tif_block.c();\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);\n\t\t\t\t\tif_block.m(if_block_anchor.parentNode, if_block_anchor);\n\t\t\t\t}\n\t\t\t} else if (if_block) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block, 1, 1, () => {\n\t\t\t\t\tif_block = null;\n\t\t\t\t});\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t}\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\tif (if_block) if_block.d(detaching);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);\n\t\t\tmounted = false;\n\t\t\tdispose();\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_fragment.name,\n\t\ttype: "component",\n\t\tsource: "",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n\tlet { $$slots: slots = {}, $$scope } = $$props;\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)(\'Pagination\', slots, []);\n\tlet { options } = $$props;\n\tlet { store } = $$props;\n\n\t// export let numOfTotalPages = 4;\n\tlet display = {\n\t\tpagination_show_previous_and_next_buttons: true,\n\t\tpagination_show_first_and_last_buttons: true\n\t};\n\n\tlet mode = "frontend";\n\tlet innerWidth = window.innerWidth;\n\tlet buttons = [-2, -1, 0, 1, 2];\n\n\tlet labels = {\n\t\tfirst: "first",\n\t\tlast: "last",\n\t\tnext: "next",\n\t\tprevious: "previous"\n\t};\n\n\t// let numOfTotalPages;\n\t// store.numOfTotalPages.subscribe((value) => {\n\t// \tnumOfTotalPages = value;\n\t// });\n\t// store.currentPage.subscribe((value) => {\n\t// \tcurrentPage = value;\n\t// });\n\tconst onChange = callbackName => {\n\t\tstore.onPaginationChange(callbackName);\n\t\treturn;\n\t\tlet pageNumber;\n\n\t\tswitch (callbackName) {\n\t\t\tcase "previous":\n\t\t\t\tpageNumber = currentPage - 1;\n\t\t\t\tbreak;\n\t\t\tcase "next":\n\t\t\t\tpageNumber = currentPage + 1;\n\t\t\t\tbreak;\n\t\t\tcase "first":\n\t\t\t\tpageNumber = 0;\n\t\t\t\tbreak;\n\t\t\tcase "last":\n\t\t\t\tpageNumber = numOfTotalPages - 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpageNumber = callbackName.split("-")[1];\n\t\t\t\tpageNumber = parseInt(pageNumber);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tconsole.log("callbackName: " + callbackName);\n\t\tconsole.log("pageNumber: " + pageNumber);\n\t\tconsole.log("currentPage: " + currentPage);\n\n\t\tif (0 > pageNumber || pageNumber > numOfTotalPages - 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tstore.updateCurrentPage(pageNumber);\n\t}; // ActionsHandlerInstance.doAction({\n\t// \ttype: "CHANGE_CURRENT_PAGE",\n\t// \tpayload: {\n\t// \t\tcurrentPage: pageNumber,\n\n\t// \t},\n\t// });\n\tconst isMobileScreen = innerWidth => innerWidth <= 640;\n\n\t// let showFirstAndLastButtons =\n\t// \tdisplay["pagination_show_first_and_last_buttons"];\n\t// let showPreviousAndNextButtons =\n\t// \tisMobileScreen(innerWidth) ||\n\t// \tdisplay["pagination_show_previous_and_next_buttons"];\n\tconst showFirstAndLastButtons = innerWidth => {\n\t\tlet show = display["pagination_show_first_and_last_buttons"];\n\n\t\tif (mode == "editor") {\n\t\t\tshow = true;\n\t\t}\n\n\t\tif (isMobileScreen(innerWidth)) {\n\t\t\tshow = false;\n\t\t}\n\n\t\treturn show;\n\t};\n\n\tconst showPreviousAndNextButtons = innerWidth => {\n\t\tlet show = true;\n\t\tshow = display["pagination_show_previous_and_next_buttons"];\n\n\t\tif (mode == "editor") {\n\t\t\tshow = true;\n\t\t}\n\n\t\treturn show;\n\t};\n\n\tconst showNumberButtons = innerWidth => {\n\t\tlet show = true;\n\n\t\t// Show Numbers for mobile only if prev and next buttons are hidden\n\t\tif (isMobileScreen(innerWidth)) {\n\t\t\tshow = !display["pagination_show_previous_and_next_buttons"];\n\t\t}\n\n\t\tif (mode == "editor") {\n\t\t\tshow = true;\n\t\t}\n\n\t\treturn show;\n\t};\n\n\tlet currentPage;\n\n\tconst unsubscribe1 = store.currentPage.subscribe(value => {\n\t\tconsole.log("currentPage value: ");\n\t\tconsole.log(value);\n\t\t$$invalidate(1, currentPage = value);\n\t});\n\n\tlet numOfTotalPages;\n\n\tstore.numOfTotalPages.subscribe(value => {\n\t\t$$invalidate(2, numOfTotalPages = value);\n\t});\n\n\t$$self.$$.on_mount.push(function () {\n\t\tif (options === undefined && !(\'options\' in $$props || $$self.$$.bound[$$self.$$.props[\'options\']])) {\n\t\t\tconsole_1.warn("<Pagination> was created without expected prop \'options\'");\n\t\t}\n\n\t\tif (store === undefined && !(\'store\' in $$props || $$self.$$.bound[$$self.$$.props[\'store\']])) {\n\t\t\tconsole_1.warn("<Pagination> was created without expected prop \'store\'");\n\t\t}\n\t});\n\n\tconst writable_props = [\'options\', \'store\'];\n\n\tObject.keys($$props).forEach(key => {\n\t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== \'$$\' && key !== \'slot\') console_1.warn(`<Pagination> was created with unknown prop \'${key}\'`);\n\t});\n\n\tfunction onwindowresize() {\n\t\t$$invalidate(0, innerWidth = window_1.innerWidth)\n\t}\n\n\t$$self.$$set = $$props => {\n\t\tif (\'options\' in $$props) $$invalidate(10, options = $$props.options);\n\t\tif (\'store\' in $$props) $$invalidate(11, store = $$props.store);\n\t};\n\n\t$$self.$capture_state = () => ({\n\t\tget: svelte_store__WEBPACK_IMPORTED_MODULE_2__.get,\n\t\tListItem: _listItem_svelte__WEBPACK_IMPORTED_MODULE_1__["default"],\n\t\toptions,\n\t\tstore,\n\t\tdisplay,\n\t\tmode,\n\t\tinnerWidth,\n\t\tbuttons,\n\t\tlabels,\n\t\tonChange,\n\t\tisMobileScreen,\n\t\tshowFirstAndLastButtons,\n\t\tshowPreviousAndNextButtons,\n\t\tshowNumberButtons,\n\t\tcurrentPage,\n\t\tunsubscribe1,\n\t\tnumOfTotalPages\n\t});\n\n\t$$self.$inject_state = $$props => {\n\t\tif (\'options\' in $$props) $$invalidate(10, options = $$props.options);\n\t\tif (\'store\' in $$props) $$invalidate(11, store = $$props.store);\n\t\tif (\'display\' in $$props) display = $$props.display;\n\t\tif (\'mode\' in $$props) mode = $$props.mode;\n\t\tif (\'innerWidth\' in $$props) $$invalidate(0, innerWidth = $$props.innerWidth);\n\t\tif (\'buttons\' in $$props) $$invalidate(3, buttons = $$props.buttons);\n\t\tif (\'labels\' in $$props) $$invalidate(4, labels = $$props.labels);\n\t\tif (\'currentPage\' in $$props) $$invalidate(1, currentPage = $$props.currentPage);\n\t\tif (\'numOfTotalPages\' in $$props) $$invalidate(2, numOfTotalPages = $$props.numOfTotalPages);\n\t};\n\n\tif ($$props && "$$inject" in $$props) {\n\t\t$$self.$inject_state($$props.$$inject);\n\t}\n\n\treturn [\n\t\tinnerWidth,\n\t\tcurrentPage,\n\t\tnumOfTotalPages,\n\t\tbuttons,\n\t\tlabels,\n\t\tonChange,\n\t\tisMobileScreen,\n\t\tshowFirstAndLastButtons,\n\t\tshowPreviousAndNextButtons,\n\t\tshowNumberButtons,\n\t\toptions,\n\t\tstore,\n\t\tonwindowresize\n\t];\n}\n\nclass Pagination extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {\n\tconstructor(options) {\n\t\tsuper(options);\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { options: 10, store: 11 });\n\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {\n\t\t\tcomponent: this,\n\t\t\ttagName: "Pagination",\n\t\t\toptions,\n\t\t\tid: create_fragment.name\n\t\t});\n\t}\n\n\tget options() {\n\t\tthrow new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset options(value) {\n\t\tthrow new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tget store() {\n\t\tthrow new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset store(value) {\n\t\tthrow new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pagination);\n\n//# sourceURL=webpack://helpie-faq/./assets/js/svelte/qna/pagination.svelte?')},"./assets/js/svelte/qna/qna.svelte":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");\n/* harmony import */ var svelte_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte/store */ "./node_modules/svelte/store/index.mjs");\n/* harmony import */ var _storeInstances_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./storeInstances.js */ "./assets/js/svelte/qna/storeInstances.js");\n/* harmony import */ var _pagination_svelte__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pagination.svelte */ "./assets/js/svelte/qna/pagination.svelte");\n/* harmony import */ var _singleQuestion_svelte__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./singleQuestion.svelte */ "./assets/js/svelte/qna/singleQuestion.svelte");\n/* harmony import */ var _submitForm_svelte__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./submitForm.svelte */ "./assets/js/svelte/qna/submitForm.svelte");\n/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");\n/* harmony import */ var C_Users_admin_Local_Sites_helpie_faq_app_public_wp_content_plugins_helpie_faq_assets_js_svelte_qna_qna_svelte_1_css_svelte_loader_cssPath_C_Users_admin_Local_Sites_helpie_faq_app_public_wp_content_plugins_helpie_faq_assets_js_svelte_qna_qna_svelte_1_css_C_Users_admin_Local_Sites_helpie_faq_app_public_wp_content_plugins_helpie_faq_assets_js_svelte_qna_qna_svelte__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./assets/js/svelte/qna/qna.svelte.1.css!=!svelte-loader?cssPath=C:/Users/admin/Local Sites/helpie-faq/app/public/wp-content/plugins/helpie-faq/assets/js/svelte/qna/qna.svelte.1.css!./assets/js/svelte/qna/qna.svelte */ "./assets/js/svelte/qna/qna.svelte.1.css!=!./node_modules/svelte-loader/index.js?cssPath=C:/Users/admin/Local Sites/helpie-faq/app/public/wp-content/plugins/helpie-faq/assets/js/svelte/qna/qna.svelte.1.css!./assets/js/svelte/qna/qna.svelte");\n/* assets\\js\\svelte\\qna\\qna.svelte generated by Svelte v3.52.0 */\n\n\nconst { console: console_1 } = svelte_internal__WEBPACK_IMPORTED_MODULE_0__.globals;\n\n\n\n\n\n\nconst file = "assets\\\\js\\\\svelte\\\\qna\\\\qna.svelte";\n\nfunction get_each_context(ctx, list, i) {\n\tconst child_ctx = ctx.slice();\n\tchild_ctx[15] = list[i];\n\treturn child_ctx;\n}\n\n// (73:1) {:catch error}\nfunction create_catch_block(ctx) {\n\tlet p;\n\tlet t_value = /*error*/ ctx[18].message + "";\n\tlet t;\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tp = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("p");\n\t\t\tt = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t_value);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(p, "color", "red");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(p, file, 73, 2, 2109);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, p, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(p, t);\n\t\t},\n\t\tp: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\td: function destroy(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(p);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_catch_block.name,\n\t\ttype: "catch",\n\t\tsource: "(73:1) {:catch error}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (1:0) <script context="module">   import { onMount }\nfunction create_then_block(ctx) {\n\tconst block = { c: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop, m: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop, p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop, d: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop };\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_then_block.name,\n\t\ttype: "then",\n\t\tsource: "(1:0) <script context=\\\\\\"module\\\\\\">   import { onMount }",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (70:17)     \x3c!-- <p>...waiting</p> --\x3e    <img class="gif" src={loadingImageUrl}\nfunction create_pending_block(ctx) {\n\tlet img;\n\tlet img_src_value;\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\timg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("img");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img, "class", "gif svelte-kmb7uz");\n\t\t\tif (!(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.src_url_equal)(img.src, img_src_value = /*loadingImageUrl*/ ctx[5])) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img, "src", img_src_value);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(img, "alt", "Loading");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(img, file, 71, 2, 2033);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, img, anchor);\n\t\t},\n\t\tp: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\td: function destroy(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(img);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_pending_block.name,\n\t\ttype: "pending",\n\t\tsource: "(70:17)     \x3c!-- <p>...waiting</p> --\x3e    <img class=\\\\\\"gif\\\\\\" src={loadingImageUrl}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (90:1) {:else}\nfunction create_else_block(ctx) {\n\tlet p;\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tp = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("p");\n\t\t\tp.textContent = "No Questions Found";\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(p, "class", "no_questions svelte-kmb7uz");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(p, file, 90, 2, 2472);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, p, anchor);\n\t\t},\n\t\tp: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\ti: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\to: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\td: function destroy(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(p);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_else_block.name,\n\t\ttype: "else",\n\t\tsource: "(90:1) {:else}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (86:1) {#if 0 < questions.length}\nfunction create_if_block_1(ctx) {\n\tlet each_1_anchor;\n\tlet current;\n\tlet each_value = /*questions*/ ctx[0];\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);\n\tlet each_blocks = [];\n\n\tfor (let i = 0; i < each_value.length; i += 1) {\n\t\teach_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n\t}\n\n\tconst out = i => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[i], 1, 1, () => {\n\t\teach_blocks[i] = null;\n\t});\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n\t\t\t\teach_blocks[i].c();\n\t\t\t}\n\n\t\t\teach_1_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n\t\t\t\teach_blocks[i].m(target, anchor);\n\t\t\t}\n\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, each_1_anchor, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tif (dirty & /*options, questions, qnaStore*/ 13) {\n\t\t\t\teach_value = /*questions*/ ctx[0];\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);\n\t\t\t\tlet i;\n\n\t\t\t\tfor (i = 0; i < each_value.length; i += 1) {\n\t\t\t\t\tconst child_ctx = get_each_context(ctx, each_value, i);\n\n\t\t\t\t\tif (each_blocks[i]) {\n\t\t\t\t\t\teach_blocks[i].p(child_ctx, dirty);\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i], 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teach_blocks[i] = create_each_block(child_ctx);\n\t\t\t\t\t\teach_blocks[i].c();\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i], 1);\n\t\t\t\t\t\teach_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\tfor (i = each_value.length; i < each_blocks.length; i += 1) {\n\t\t\t\t\tout(i);\n\t\t\t\t}\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t}\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\n\t\t\tfor (let i = 0; i < each_value.length; i += 1) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i]);\n\t\t\t}\n\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\teach_blocks = each_blocks.filter(Boolean);\n\n\t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[i]);\n\t\t\t}\n\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_each)(each_blocks, detaching);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(each_1_anchor);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block_1.name,\n\t\ttype: "if",\n\t\tsource: "(86:1) {#if 0 < questions.length}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (87:2) {#each questions as question}\nfunction create_each_block(ctx) {\n\tlet singlequestion;\n\tlet current;\n\n\tsinglequestion = new _singleQuestion_svelte__WEBPACK_IMPORTED_MODULE_4__["default"]({\n\t\t\tprops: {\n\t\t\t\toptions: /*options*/ ctx[3],\n\t\t\t\tquestion: /*question*/ ctx[15],\n\t\t\t\tqnaStore: /*qnaStore*/ ctx[2]\n\t\t\t},\n\t\t\t$$inline: true\n\t\t});\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(singlequestion.$$.fragment);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(singlequestion, target, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tconst singlequestion_changes = {};\n\t\t\tif (dirty & /*questions*/ 1) singlequestion_changes.question = /*question*/ ctx[15];\n\t\t\tsinglequestion.$set(singlequestion_changes);\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(singlequestion.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(singlequestion.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(singlequestion, detaching);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_each_block.name,\n\t\ttype: "each",\n\t\tsource: "(87:2) {#each questions as question}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (96:3) {#if options["canAddQuestion"]}\nfunction create_if_block(ctx) {\n\tlet submitform;\n\tlet current;\n\n\tsubmitform = new _submitForm_svelte__WEBPACK_IMPORTED_MODULE_5__["default"]({\n\t\t\tprops: { type: "question" },\n\t\t\t$$inline: true\n\t\t});\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(submitform.$$.fragment);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(submitform, target, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(submitform.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(submitform.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(submitform, detaching);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block.name,\n\t\ttype: "if",\n\t\tsource: "(96:3) {#if options[\\\\\\"canAddQuestion\\\\\\"]}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\nfunction create_fragment(ctx) {\n\tlet div4;\n\tlet div0;\n\tlet t0;\n\tlet promise_1;\n\tlet t1;\n\tlet input;\n\tlet t2;\n\tlet current_block_type_index;\n\tlet if_block0;\n\tlet t3;\n\tlet div3;\n\tlet div1;\n\tlet t5;\n\tlet div2;\n\tlet t6;\n\tlet pagination;\n\tlet current;\n\tlet mounted;\n\tlet dispose;\n\n\tlet info = {\n\t\tctx,\n\t\tcurrent: null,\n\t\ttoken: null,\n\t\thasCatch: true,\n\t\tpending: create_pending_block,\n\t\tthen: create_then_block,\n\t\tcatch: create_catch_block,\n\t\terror: 18\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.handle_promise)(promise_1 = /*promise*/ ctx[4], info);\n\tconst if_block_creators = [create_if_block_1, create_else_block];\n\tconst if_blocks = [];\n\n\tfunction select_block_type(ctx, dirty) {\n\t\tif (0 < /*questions*/ ctx[0].length) return 0;\n\t\treturn 1;\n\t}\n\n\tcurrent_block_type_index = select_block_type(ctx, -1);\n\tif_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n\tlet if_block1 = /*options*/ ctx[3]["canAddQuestion"] && create_if_block(ctx);\n\n\tpagination = new _pagination_svelte__WEBPACK_IMPORTED_MODULE_3__["default"]({\n\t\t\tprops: {\n\t\t\t\toptions: /*options*/ ctx[3],\n\t\t\t\tstore: /*qnaStore*/ ctx[2],\n\t\t\t\tsearchText: /*searchText*/ ctx[1]\n\t\t\t},\n\t\t\t$$inline: true\n\t\t});\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tdiv4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tdiv0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tt0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tinfo.block.c();\n\t\t\tt1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tinput = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("input");\n\t\t\tt2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tif_block0.c();\n\t\t\tt3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tdiv3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tdiv1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tdiv1.textContent = " ";\n\t\t\tt5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tdiv2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tif (if_block1) if_block1.c();\n\t\t\tt6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(pagination.$$.fragment);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 68, 1, 1973);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input, "class", "search");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input, "type", "text");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(input, "placeholder", "Search..");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(input, file, 76, 1, 2166);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "col col__2");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 93, 2, 2550);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div2, "class", "col col__10");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 94, 2, 2590);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "class", "row");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div3, file, 92, 1, 2529);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div4, "class", "helpiefaq__qna__section");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div4, file, 67, 0, 1933);\n\t\t},\n\t\tl: function claim(nodes) {\n\t\t\tthrow new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div4, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, div0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, t0);\n\t\t\tinfo.block.m(div4, info.anchor = null);\n\t\t\tinfo.mount = () => div4;\n\t\t\tinfo.anchor = t1;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, t1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, input);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(input, /*searchText*/ ctx[1]);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, t2);\n\t\t\tif_blocks[current_block_type_index].m(div4, null);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, t3);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, div3);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t5);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div2);\n\t\t\tif (if_block1) if_block1.m(div2, null);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div4, t6);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(pagination, div4, null);\n\t\t\tcurrent = true;\n\n\t\t\tif (!mounted) {\n\t\t\t\tdispose = [\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(input, "input", /*input_input_handler*/ ctx[6]),\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(input, "input", /*input_handler*/ ctx[7], false, false, false)\n\t\t\t\t];\n\n\t\t\t\tmounted = true;\n\t\t\t}\n\t\t},\n\t\tp: function update(new_ctx, [dirty]) {\n\t\t\tctx = new_ctx;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.update_await_block_branch)(info, ctx, dirty);\n\n\t\t\tif (dirty & /*searchText*/ 2 && input.value !== /*searchText*/ ctx[1]) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(input, /*searchText*/ ctx[1]);\n\t\t\t}\n\n\t\t\tlet previous_block_index = current_block_type_index;\n\t\t\tcurrent_block_type_index = select_block_type(ctx, dirty);\n\n\t\t\tif (current_block_type_index === previous_block_index) {\n\t\t\t\tif_blocks[current_block_type_index].p(ctx, dirty);\n\t\t\t} else {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_blocks[previous_block_index], 1, 1, () => {\n\t\t\t\t\tif_blocks[previous_block_index] = null;\n\t\t\t\t});\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t\tif_block0 = if_blocks[current_block_type_index];\n\n\t\t\t\tif (!if_block0) {\n\t\t\t\t\tif_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n\t\t\t\t\tif_block0.c();\n\t\t\t\t} else {\n\t\t\t\t\tif_block0.p(ctx, dirty);\n\t\t\t\t}\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);\n\t\t\t\tif_block0.m(div4, t3);\n\t\t\t}\n\n\t\t\tconst pagination_changes = {};\n\t\t\tif (dirty & /*searchText*/ 2) pagination_changes.searchText = /*searchText*/ ctx[1];\n\t\t\tpagination.$set(pagination_changes);\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(pagination.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(pagination.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div4);\n\t\t\tinfo.block.d();\n\t\t\tinfo.token = null;\n\t\t\tinfo = null;\n\t\t\tif_blocks[current_block_type_index].d();\n\t\t\tif (if_block1) if_block1.d();\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(pagination);\n\t\t\tmounted = false;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_fragment.name,\n\t\ttype: "component",\n\t\tsource: "",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n\tlet searchText;\n\tlet currentPage;\n\tlet { $$slots: slots = {}, $$scope } = $$props;\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)(\'Qna\', slots, []);\n\tlet qnaCapabilities = helpie_faq_object.qna_capabilities;\n\tlet qnaStore = _storeInstances_js__WEBPACK_IMPORTED_MODULE_2__["default"];\n\tlet questions = [];\n\n\tlet options = {\n\t\tshowUpVote: true,\n\t\tshowDownVote: false,\n\t\tcanVoteQuestion: qnaCapabilities["can_vote_question"],\n\t\tcanAddAnswer: qnaCapabilities["can_add_answer"],\n\t\tcanAddQuestion: qnaCapabilities["can_add_question"]\n\t}; // \'canVoteAnswer\': false,\n\n\tlet postargs = {\n\t\taction: "helpie_qna_get_posts",\n\t\tnonce: thisModule.nonce,\n\t\tcurrent_post_id: helpie_faq_object.current_post_id\n\t};\n\n\tlet promise = getPosts(postargs);\n\n\t// console.log("qnaStore: ");\n\t// console.log(qnaStore);\n\t// console.log("questions: ");\n\t// console.log(questions);\n\t// console.log("qnaCapabilities: ");\n\t// console.log(qnaCapabilities);\n\tasync function getPosts(postargs) {\n\t\tawait qnaStore.getPosts(postargs);\n\t}\n\n\t// console.log("qnaStore.viewableQuestions.subscribe: ");\n\t// console.log(qnaStore.viewableQuestions.subscribe);\n\tconst unsubscribe1 = qnaStore.viewableQuestions.subscribe(value => {\n\t\tconsole.log("viewableQuestions value: ");\n\t\t$$invalidate(0, questions = []);\n\t\tconsole.log(value);\n\t\t$$invalidate(0, questions = JSON.parse(JSON.stringify(value)));\n\t});\n\n\tconst unsubscribe2 = qnaStore.searchText.subscribe(value => {\n\t\tconsole.log("searchText value: " + value);\n\t\t$$invalidate(1, searchText = value);\n\t});\n\n\tconst unsubscribe3 = qnaStore.currentPage.subscribe(value => {\n\t\tconsole.log("searchText value: " + value);\n\t\tcurrentPage = value;\n\t});\n\n\tlet loadingImageUrl = helpie_faq_object.url + "assets/img/moving-train.gif";\n\tconst writable_props = [];\n\n\tObject.keys($$props).forEach(key => {\n\t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== \'$$\' && key !== \'slot\') console_1.warn(`<Qna> was created with unknown prop \'${key}\'`);\n\t});\n\n\tfunction input_input_handler() {\n\t\tsearchText = this.value;\n\t\t$$invalidate(1, searchText);\n\t}\n\n\tconst input_handler = () => {\n\t\tqnaStore.setSearchText(searchText);\n\t};\n\n\t$$self.$capture_state = () => ({\n\t\tonMount: svelte__WEBPACK_IMPORTED_MODULE_6__.onMount,\n\t\tSubmitForm: _submitForm_svelte__WEBPACK_IMPORTED_MODULE_5__["default"],\n\t\tSingleQuestion: _singleQuestion_svelte__WEBPACK_IMPORTED_MODULE_4__["default"],\n\t\tPagination: _pagination_svelte__WEBPACK_IMPORTED_MODULE_3__["default"],\n\t\tStoreInstances: _storeInstances_js__WEBPACK_IMPORTED_MODULE_2__["default"],\n\t\tget: svelte_store__WEBPACK_IMPORTED_MODULE_1__.get,\n\t\tqnaCapabilities,\n\t\tqnaStore,\n\t\tquestions,\n\t\toptions,\n\t\tpostargs,\n\t\tpromise,\n\t\tgetPosts,\n\t\tunsubscribe1,\n\t\tunsubscribe2,\n\t\tunsubscribe3,\n\t\tloadingImageUrl,\n\t\tcurrentPage,\n\t\tsearchText\n\t});\n\n\t$$self.$inject_state = $$props => {\n\t\tif (\'qnaCapabilities\' in $$props) qnaCapabilities = $$props.qnaCapabilities;\n\t\tif (\'qnaStore\' in $$props) $$invalidate(2, qnaStore = $$props.qnaStore);\n\t\tif (\'questions\' in $$props) $$invalidate(0, questions = $$props.questions);\n\t\tif (\'options\' in $$props) $$invalidate(3, options = $$props.options);\n\t\tif (\'postargs\' in $$props) postargs = $$props.postargs;\n\t\tif (\'promise\' in $$props) $$invalidate(4, promise = $$props.promise);\n\t\tif (\'loadingImageUrl\' in $$props) $$invalidate(5, loadingImageUrl = $$props.loadingImageUrl);\n\t\tif (\'currentPage\' in $$props) currentPage = $$props.currentPage;\n\t\tif (\'searchText\' in $$props) $$invalidate(1, searchText = $$props.searchText);\n\t};\n\n\tif ($$props && "$$inject" in $$props) {\n\t\t$$self.$inject_state($$props.$$inject);\n\t}\n\n\t$: $$invalidate(1, searchText = "");\n\t$: currentPage = 1;\n\n\treturn [\n\t\tquestions,\n\t\tsearchText,\n\t\tqnaStore,\n\t\toptions,\n\t\tpromise,\n\t\tloadingImageUrl,\n\t\tinput_input_handler,\n\t\tinput_handler\n\t];\n}\n\nclass Qna extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {\n\tconstructor(options) {\n\t\tsuper(options);\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});\n\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {\n\t\t\tcomponent: this,\n\t\t\ttagName: "Qna",\n\t\t\toptions,\n\t\t\tid: create_fragment.name\n\t\t});\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Qna);\n\n\n//# sourceURL=webpack://helpie-faq/./assets/js/svelte/qna/qna.svelte?')},"./assets/js/svelte/qna/showMore.svelte":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");\n/* harmony import */ var C_Users_admin_Local_Sites_helpie_faq_app_public_wp_content_plugins_helpie_faq_assets_js_svelte_qna_showMore_svelte_5_css_svelte_loader_cssPath_C_Users_admin_Local_Sites_helpie_faq_app_public_wp_content_plugins_helpie_faq_assets_js_svelte_qna_showMore_svelte_5_css_C_Users_admin_Local_Sites_helpie_faq_app_public_wp_content_plugins_helpie_faq_assets_js_svelte_qna_showMore_svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assets/js/svelte/qna/showMore.svelte.5.css!=!svelte-loader?cssPath=C:/Users/admin/Local Sites/helpie-faq/app/public/wp-content/plugins/helpie-faq/assets/js/svelte/qna/showMore.svelte.5.css!./assets/js/svelte/qna/showMore.svelte */ "./assets/js/svelte/qna/showMore.svelte.5.css!=!./node_modules/svelte-loader/index.js?cssPath=C:/Users/admin/Local Sites/helpie-faq/app/public/wp-content/plugins/helpie-faq/assets/js/svelte/qna/showMore.svelte.5.css!./assets/js/svelte/qna/showMore.svelte");\n/* assets\\js\\svelte\\qna\\showMore.svelte generated by Svelte v3.52.0 */\n\n\nconst file = "assets\\\\js\\\\svelte\\\\qna\\\\showMore.svelte";\n\n// (9:0) {#if ii == 0}\nfunction create_if_block(ctx) {\n\tlet div3;\n\tlet div0;\n\tlet t1;\n\tlet div2;\n\tlet div1;\n\tlet a;\n\tlet t2;\n\tlet mounted;\n\tlet dispose;\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tdiv3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tdiv0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tdiv0.textContent = " ";\n\t\t\tt1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tdiv2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tdiv1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\ta = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("a");\n\t\t\tt2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(/*showMoreText*/ ctx[3]);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "col col__2");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 10, 2, 199);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a, "class", "svelte-dofab0");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(a, file, 13, 4, 297);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "showMore svelte-dofab0");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 12, 3, 269);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div2, "class", "col col__10");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 11, 2, 239);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "class", "row");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div3, file, 9, 1, 178);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div3, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, t1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div3, div2);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, div1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, a);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(a, t2);\n\n\t\t\tif (!mounted) {\n\t\t\t\tdispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(a, "click", /*click_handler*/ ctx[4], false, false, false);\n\t\t\t\tmounted = true;\n\t\t\t}\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tif (dirty & /*showMoreText*/ 8) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t2, /*showMoreText*/ ctx[3]);\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div3);\n\t\t\tmounted = false;\n\t\t\tdispose();\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block.name,\n\t\ttype: "if",\n\t\tsource: "(9:0) {#if ii == 0}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\nfunction create_fragment(ctx) {\n\tlet if_block_anchor;\n\tlet if_block = /*ii*/ ctx[1] == 0 && create_if_block(ctx);\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tif (if_block) if_block.c();\n\t\t\tif_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();\n\t\t},\n\t\tl: function claim(nodes) {\n\t\t\tthrow new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\tif (if_block) if_block.m(target, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);\n\t\t},\n\t\tp: function update(ctx, [dirty]) {\n\t\t\tif (/*ii*/ ctx[1] == 0) {\n\t\t\t\tif (if_block) {\n\t\t\t\t\tif_block.p(ctx, dirty);\n\t\t\t\t} else {\n\t\t\t\t\tif_block = create_if_block(ctx);\n\t\t\t\t\tif_block.c();\n\t\t\t\t\tif_block.m(if_block_anchor.parentNode, if_block_anchor);\n\t\t\t\t}\n\t\t\t} else if (if_block) {\n\t\t\t\tif_block.d(1);\n\t\t\t\tif_block = null;\n\t\t\t}\n\t\t},\n\t\ti: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\to: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\td: function destroy(detaching) {\n\t\t\tif (if_block) if_block.d(detaching);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_fragment.name,\n\t\ttype: "component",\n\t\tsource: "",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n\tlet showMoreText;\n\tlet { $$slots: slots = {}, $$scope } = $$props;\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)(\'ShowMore\', slots, []);\n\tlet { showMore } = $$props;\n\tlet { ii } = $$props;\n\tlet { toggleShow } = $$props;\n\n\t$$self.$$.on_mount.push(function () {\n\t\tif (showMore === undefined && !(\'showMore\' in $$props || $$self.$$.bound[$$self.$$.props[\'showMore\']])) {\n\t\t\tconsole.warn("<ShowMore> was created without expected prop \'showMore\'");\n\t\t}\n\n\t\tif (ii === undefined && !(\'ii\' in $$props || $$self.$$.bound[$$self.$$.props[\'ii\']])) {\n\t\t\tconsole.warn("<ShowMore> was created without expected prop \'ii\'");\n\t\t}\n\n\t\tif (toggleShow === undefined && !(\'toggleShow\' in $$props || $$self.$$.bound[$$self.$$.props[\'toggleShow\']])) {\n\t\t\tconsole.warn("<ShowMore> was created without expected prop \'toggleShow\'");\n\t\t}\n\t});\n\n\tconst writable_props = [\'showMore\', \'ii\', \'toggleShow\'];\n\n\tObject.keys($$props).forEach(key => {\n\t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== \'$$\' && key !== \'slot\') console.warn(`<ShowMore> was created with unknown prop \'${key}\'`);\n\t});\n\n\tconst click_handler = () => toggleShow(!showMore);\n\n\t$$self.$$set = $$props => {\n\t\tif (\'showMore\' in $$props) $$invalidate(0, showMore = $$props.showMore);\n\t\tif (\'ii\' in $$props) $$invalidate(1, ii = $$props.ii);\n\t\tif (\'toggleShow\' in $$props) $$invalidate(2, toggleShow = $$props.toggleShow);\n\t};\n\n\t$$self.$capture_state = () => ({ showMore, ii, toggleShow, showMoreText });\n\n\t$$self.$inject_state = $$props => {\n\t\tif (\'showMore\' in $$props) $$invalidate(0, showMore = $$props.showMore);\n\t\tif (\'ii\' in $$props) $$invalidate(1, ii = $$props.ii);\n\t\tif (\'toggleShow\' in $$props) $$invalidate(2, toggleShow = $$props.toggleShow);\n\t\tif (\'showMoreText\' in $$props) $$invalidate(3, showMoreText = $$props.showMoreText);\n\t};\n\n\tif ($$props && "$$inject" in $$props) {\n\t\t$$self.$inject_state($$props.$$inject);\n\t}\n\n\t$$self.$$.update = () => {\n\t\tif ($$self.$$.dirty & /*showMore*/ 1) {\n\t\t\t$: $$invalidate(3, showMoreText = showMore ? "See Less Answers" : "See More Answers");\n\t\t}\n\t};\n\n\treturn [showMore, ii, toggleShow, showMoreText, click_handler];\n}\n\nclass ShowMore extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {\n\tconstructor(options) {\n\t\tsuper(options);\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { showMore: 0, ii: 1, toggleShow: 2 });\n\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {\n\t\t\tcomponent: this,\n\t\t\ttagName: "ShowMore",\n\t\t\toptions,\n\t\t\tid: create_fragment.name\n\t\t});\n\t}\n\n\tget showMore() {\n\t\tthrow new Error("<ShowMore>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset showMore(value) {\n\t\tthrow new Error("<ShowMore>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tget ii() {\n\t\tthrow new Error("<ShowMore>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset ii(value) {\n\t\tthrow new Error("<ShowMore>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tget toggleShow() {\n\t\tthrow new Error("<ShowMore>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset toggleShow(value) {\n\t\tthrow new Error("<ShowMore>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ShowMore);\n\n\n//# sourceURL=webpack://helpie-faq/./assets/js/svelte/qna/showMore.svelte?')},"./assets/js/svelte/qna/singleAnswer.svelte":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");\n/* assets\\js\\svelte\\qna\\singleAnswer.svelte generated by Svelte v3.52.0 */\n\n\nconst file = "assets\\\\js\\\\svelte\\\\qna\\\\singleAnswer.svelte";\n\nfunction create_fragment(ctx) {\n\tlet div2;\n\tlet div0;\n\tlet t1;\n\tlet div1;\n\tlet p0;\n\tlet t2_value = /*answer*/ ctx[0].content + "";\n\tlet t2;\n\tlet t3;\n\tlet p1;\n\tlet t4;\n\n\tlet t5_value = (/*answer*/ ctx[0].answer_by\n\t? /*answer*/ ctx[0].answer_by\n\t: "anonymous") + "";\n\n\tlet t5;\n\tlet t6;\n\tlet t7_value = /*answer*/ ctx[0].human_time_diff + "";\n\tlet t7;\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tdiv2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tdiv0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tdiv0.textContent = " ";\n\t\t\tt1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tdiv1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tp0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("p");\n\t\t\tt2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t2_value);\n\t\t\tt3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tp1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("p");\n\t\t\tt4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)("Answered by ");\n\t\t\tt5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t5_value);\n\t\t\tt6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tt7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t7_value);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "col col__2");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 5, 1, 98);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(p0, file, 7, 2, 166);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(p1, "class", "qna-answer-meta");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(p1, file, 11, 2, 250);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "col col__10");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 6, 1, 137);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div2, "class", "helpiefaq__singleqna__answer row");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 4, 0, 49);\n\t\t},\n\t\tl: function claim(nodes) {\n\t\t\tthrow new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div2, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, div0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, t1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, div1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, p0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(p0, t2);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, t3);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, p1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(p1, t4);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(p1, t5);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(p1, t6);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(p1, t7);\n\t\t},\n\t\tp: function update(ctx, [dirty]) {\n\t\t\tif (dirty & /*answer*/ 1 && t2_value !== (t2_value = /*answer*/ ctx[0].content + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t2, t2_value);\n\n\t\t\tif (dirty & /*answer*/ 1 && t5_value !== (t5_value = (/*answer*/ ctx[0].answer_by\n\t\t\t? /*answer*/ ctx[0].answer_by\n\t\t\t: "anonymous") + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t5, t5_value);\n\n\t\t\tif (dirty & /*answer*/ 1 && t7_value !== (t7_value = /*answer*/ ctx[0].human_time_diff + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t7, t7_value);\n\t\t},\n\t\ti: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\to: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\td: function destroy(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div2);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_fragment.name,\n\t\ttype: "component",\n\t\tsource: "",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n\tlet { $$slots: slots = {}, $$scope } = $$props;\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)(\'SingleAnswer\', slots, []);\n\tlet { answer = {} } = $$props;\n\tconst writable_props = [\'answer\'];\n\n\tObject.keys($$props).forEach(key => {\n\t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== \'$$\' && key !== \'slot\') console.warn(`<SingleAnswer> was created with unknown prop \'${key}\'`);\n\t});\n\n\t$$self.$$set = $$props => {\n\t\tif (\'answer\' in $$props) $$invalidate(0, answer = $$props.answer);\n\t};\n\n\t$$self.$capture_state = () => ({ answer });\n\n\t$$self.$inject_state = $$props => {\n\t\tif (\'answer\' in $$props) $$invalidate(0, answer = $$props.answer);\n\t};\n\n\tif ($$props && "$$inject" in $$props) {\n\t\t$$self.$inject_state($$props.$$inject);\n\t}\n\n\treturn [answer];\n}\n\nclass SingleAnswer extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {\n\tconstructor(options) {\n\t\tsuper(options);\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { answer: 0 });\n\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {\n\t\t\tcomponent: this,\n\t\t\ttagName: "SingleAnswer",\n\t\t\toptions,\n\t\t\tid: create_fragment.name\n\t\t});\n\t}\n\n\tget answer() {\n\t\tthrow new Error("<SingleAnswer>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset answer(value) {\n\t\tthrow new Error("<SingleAnswer>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SingleAnswer);\n\n//# sourceURL=webpack://helpie-faq/./assets/js/svelte/qna/singleAnswer.svelte?')},"./assets/js/svelte/qna/singleQuestion.svelte":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");\n/* harmony import */ var _showMore_svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./showMore.svelte */ "./assets/js/svelte/qna/showMore.svelte");\n/* harmony import */ var _singleAnswer_svelte__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./singleAnswer.svelte */ "./assets/js/svelte/qna/singleAnswer.svelte");\n/* harmony import */ var _submitForm_svelte__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./submitForm.svelte */ "./assets/js/svelte/qna/submitForm.svelte");\n/* harmony import */ var _voteButton_svelte__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./voteButton.svelte */ "./assets/js/svelte/qna/voteButton.svelte");\n/* assets\\js\\svelte\\qna\\singleQuestion.svelte generated by Svelte v3.52.0 */\n\n\nconst { console: console_1 } = svelte_internal__WEBPACK_IMPORTED_MODULE_0__.globals;\n\n\n\n\nconst file = "assets\\\\js\\\\svelte\\\\qna\\\\singleQuestion.svelte";\n\nfunction get_each_context(ctx, list, i) {\n\tconst child_ctx = ctx.slice();\n\tchild_ctx[7] = list[i];\n\tchild_ctx[9] = i;\n\treturn child_ctx;\n}\n\n// (31:3) {#if options["canVoteQuestion"]}\nfunction create_if_block_3(ctx) {\n\tlet votebutton;\n\tlet current;\n\n\tvotebutton = new _voteButton_svelte__WEBPACK_IMPORTED_MODULE_4__["default"]({\n\t\t\tprops: {\n\t\t\t\tvoteFor: "question",\n\t\t\t\tquestionId: /*question*/ ctx[0].id,\n\t\t\t\tvotes: /*votes*/ ctx[4],\n\t\t\t\tcurrentUserVotes: /*currentUserVotes*/ ctx[3],\n\t\t\t\toptions: /*options*/ ctx[1]\n\t\t\t},\n\t\t\t$$inline: true\n\t\t});\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(votebutton.$$.fragment);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(votebutton, target, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tconst votebutton_changes = {};\n\t\t\tif (dirty & /*question*/ 1) votebutton_changes.questionId = /*question*/ ctx[0].id;\n\t\t\tif (dirty & /*votes*/ 16) votebutton_changes.votes = /*votes*/ ctx[4];\n\t\t\tif (dirty & /*currentUserVotes*/ 8) votebutton_changes.currentUserVotes = /*currentUserVotes*/ ctx[3];\n\t\t\tif (dirty & /*options*/ 2) votebutton_changes.options = /*options*/ ctx[1];\n\t\t\tvotebutton.$set(votebutton_changes);\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(votebutton.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(votebutton.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(votebutton, detaching);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block_3.name,\n\t\ttype: "if",\n\t\tsource: "(31:3) {#if options[\\\\\\"canVoteQuestion\\\\\\"]}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (51:2) {#if ii == 0 || showMore == true}\nfunction create_if_block_2(ctx) {\n\tlet singleanswer;\n\tlet current;\n\n\tsingleanswer = new _singleAnswer_svelte__WEBPACK_IMPORTED_MODULE_2__["default"]({\n\t\t\tprops: { answer: /*answer*/ ctx[7] },\n\t\t\t$$inline: true\n\t\t});\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(singleanswer.$$.fragment);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(singleanswer, target, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tconst singleanswer_changes = {};\n\t\t\tif (dirty & /*question*/ 1) singleanswer_changes.answer = /*answer*/ ctx[7];\n\t\t\tsingleanswer.$set(singleanswer_changes);\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(singleanswer.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(singleanswer.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(singleanswer, detaching);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block_2.name,\n\t\ttype: "if",\n\t\tsource: "(51:2) {#if ii == 0 || showMore == true}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (55:2) {#if question.answers.length > 1}\nfunction create_if_block_1(ctx) {\n\tlet showmore;\n\tlet current;\n\n\tshowmore = new _showMore_svelte__WEBPACK_IMPORTED_MODULE_1__["default"]({\n\t\t\tprops: {\n\t\t\t\tshowMore: /*showMore*/ ctx[2],\n\t\t\t\tii: /*ii*/ ctx[9],\n\t\t\t\ttoggleShow: /*toggleShow*/ ctx[5]\n\t\t\t},\n\t\t\t$$inline: true\n\t\t});\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(showmore.$$.fragment);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(showmore, target, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tconst showmore_changes = {};\n\t\t\tif (dirty & /*showMore*/ 4) showmore_changes.showMore = /*showMore*/ ctx[2];\n\t\t\tshowmore.$set(showmore_changes);\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(showmore.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(showmore.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(showmore, detaching);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block_1.name,\n\t\ttype: "if",\n\t\tsource: "(55:2) {#if question.answers.length > 1}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (50:1) {#each question.answers as answer, ii}\nfunction create_each_block(ctx) {\n\tlet t;\n\tlet if_block1_anchor;\n\tlet current;\n\tlet if_block0 = (/*ii*/ ctx[9] == 0 || /*showMore*/ ctx[2] == true) && create_if_block_2(ctx);\n\tlet if_block1 = /*question*/ ctx[0].answers.length > 1 && create_if_block_1(ctx);\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tif (if_block0) if_block0.c();\n\t\t\tt = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tif (if_block1) if_block1.c();\n\t\t\tif_block1_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\tif (if_block0) if_block0.m(target, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t, anchor);\n\t\t\tif (if_block1) if_block1.m(target, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block1_anchor, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tif (/*ii*/ ctx[9] == 0 || /*showMore*/ ctx[2] == true) {\n\t\t\t\tif (if_block0) {\n\t\t\t\t\tif_block0.p(ctx, dirty);\n\n\t\t\t\t\tif (dirty & /*showMore*/ 4) {\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif_block0 = create_if_block_2(ctx);\n\t\t\t\t\tif_block0.c();\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);\n\t\t\t\t\tif_block0.m(t.parentNode, t);\n\t\t\t\t}\n\t\t\t} else if (if_block0) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0, 1, 1, () => {\n\t\t\t\t\tif_block0 = null;\n\t\t\t\t});\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t}\n\n\t\t\tif (/*question*/ ctx[0].answers.length > 1) {\n\t\t\t\tif (if_block1) {\n\t\t\t\t\tif_block1.p(ctx, dirty);\n\n\t\t\t\t\tif (dirty & /*question*/ 1) {\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1, 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif_block1 = create_if_block_1(ctx);\n\t\t\t\t\tif_block1.c();\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1, 1);\n\t\t\t\t\tif_block1.m(if_block1_anchor.parentNode, if_block1_anchor);\n\t\t\t\t}\n\t\t\t} else if (if_block1) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block1, 1, 1, () => {\n\t\t\t\t\tif_block1 = null;\n\t\t\t\t});\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t}\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block1);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\tif (if_block0) if_block0.d(detaching);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t);\n\t\t\tif (if_block1) if_block1.d(detaching);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block1_anchor);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_each_block.name,\n\t\ttype: "each",\n\t\tsource: "(50:1) {#each question.answers as answer, ii}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (62:3) {#if options["canAddAnswer"] && !question.userHasAlreadyAnswered}\nfunction create_if_block(ctx) {\n\tlet submitform;\n\tlet current;\n\n\tsubmitform = new _submitForm_svelte__WEBPACK_IMPORTED_MODULE_3__["default"]({\n\t\t\tprops: {\n\t\t\t\ttype: "answer",\n\t\t\t\tquestionId: /*question*/ ctx[0].id\n\t\t\t},\n\t\t\t$$inline: true\n\t\t});\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(submitform.$$.fragment);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(submitform, target, anchor);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tconst submitform_changes = {};\n\t\t\tif (dirty & /*question*/ 1) submitform_changes.questionId = /*question*/ ctx[0].id;\n\t\t\tsubmitform.$set(submitform_changes);\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(submitform.$$.fragment, local);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(submitform.$$.fragment, local);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(submitform, detaching);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block.name,\n\t\ttype: "if",\n\t\tsource: "(62:3) {#if options[\\\\\\"canAddAnswer\\\\\\"] && !question.userHasAlreadyAnswered}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\nfunction create_fragment(ctx) {\n\tlet div6;\n\tlet div2;\n\tlet div0;\n\tlet t0;\n\tlet t1;\n\tlet div1;\n\tlet a;\n\tlet t2_value = /*question*/ ctx[0].content + "";\n\tlet t2;\n\tlet a_href_value;\n\tlet t3;\n\tlet t4;\n\tlet div5;\n\tlet div3;\n\tlet t6;\n\tlet div4;\n\tlet current;\n\tlet if_block0 = /*options*/ ctx[1]["canVoteQuestion"] && create_if_block_3(ctx);\n\tlet each_value = /*question*/ ctx[0].answers;\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);\n\tlet each_blocks = [];\n\n\tfor (let i = 0; i < each_value.length; i += 1) {\n\t\teach_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n\t}\n\n\tconst out = i => (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[i], 1, 1, () => {\n\t\teach_blocks[i] = null;\n\t});\n\n\tlet if_block1 = /*options*/ ctx[1]["canAddAnswer"] && !/*question*/ ctx[0].userHasAlreadyAnswered && create_if_block(ctx);\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tdiv6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tdiv2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tdiv0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tif (if_block0) if_block0.c();\n\t\t\tt0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)("\\r\\n\\t\\t\\t ");\n\t\t\tt1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tdiv1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\ta = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("a");\n\t\t\tt2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t2_value);\n\t\t\tt3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\n\t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n\t\t\t\teach_blocks[i].c();\n\t\t\t}\n\n\t\t\tt4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tdiv5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tdiv3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tdiv3.textContent = " ";\n\t\t\tt6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tdiv4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tif (if_block1) if_block1.c();\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "col__2");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 29, 2, 764);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a, "href", a_href_value = /*question*/ ctx[0].url);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a, "target", "_blank");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(a, file, 42, 3, 1018);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "col__10");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 41, 2, 992);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div2, "class", "helpiefaq__singleqna__question row");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div2, file, 27, 1, 660);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div3, "class", "col col__2");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div3, file, 59, 2, 1404);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div4, "class", "col col__10");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div4, file, 60, 2, 1444);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div5, "class", "row");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div5, file, 58, 1, 1383);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div6, "class", "helpiefaq__singleqna");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div6, file, 26, 0, 623);\n\t\t},\n\t\tl: function claim(nodes) {\n\t\t\tthrow new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div6, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, div2);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, div0);\n\t\t\tif (if_block0) if_block0.m(div0, null);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, t0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, t1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div2, div1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, a);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(a, t2);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, t3);\n\n\t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n\t\t\t\teach_blocks[i].m(div6, null);\n\t\t\t}\n\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, t4);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div6, div5);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, div3);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, t6);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div5, div4);\n\t\t\tif (if_block1) if_block1.m(div4, null);\n\t\t\tcurrent = true;\n\t\t},\n\t\tp: function update(ctx, [dirty]) {\n\t\t\tif (/*options*/ ctx[1]["canVoteQuestion"]) {\n\t\t\t\tif (if_block0) {\n\t\t\t\t\tif_block0.p(ctx, dirty);\n\n\t\t\t\t\tif (dirty & /*options*/ 2) {\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif_block0 = create_if_block_3(ctx);\n\t\t\t\t\tif_block0.c();\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);\n\t\t\t\t\tif_block0.m(div0, t0);\n\t\t\t\t}\n\t\t\t} else if (if_block0) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0, 1, 1, () => {\n\t\t\t\t\tif_block0 = null;\n\t\t\t\t});\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t}\n\n\t\t\tif ((!current || dirty & /*question*/ 1) && t2_value !== (t2_value = /*question*/ ctx[0].content + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t2, t2_value);\n\n\t\t\tif (!current || dirty & /*question*/ 1 && a_href_value !== (a_href_value = /*question*/ ctx[0].url)) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(a, "href", a_href_value);\n\t\t\t}\n\n\t\t\tif (dirty & /*showMore, toggleShow, question*/ 37) {\n\t\t\t\teach_value = /*question*/ ctx[0].answers;\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_each_argument)(each_value);\n\t\t\t\tlet i;\n\n\t\t\t\tfor (i = 0; i < each_value.length; i += 1) {\n\t\t\t\t\tconst child_ctx = get_each_context(ctx, each_value, i);\n\n\t\t\t\t\tif (each_blocks[i]) {\n\t\t\t\t\t\teach_blocks[i].p(child_ctx, dirty);\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i], 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\teach_blocks[i] = create_each_block(child_ctx);\n\t\t\t\t\t\teach_blocks[i].c();\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i], 1);\n\t\t\t\t\t\teach_blocks[i].m(div6, t4);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\tfor (i = each_value.length; i < each_blocks.length; i += 1) {\n\t\t\t\t\tout(i);\n\t\t\t\t}\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t}\n\n\t\t\tif (/*options*/ ctx[1]["canAddAnswer"] && !/*question*/ ctx[0].userHasAlreadyAnswered) {\n\t\t\t\tif (if_block1) {\n\t\t\t\t\tif_block1.p(ctx, dirty);\n\n\t\t\t\t\tif (dirty & /*options, question*/ 3) {\n\t\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1, 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif_block1 = create_if_block(ctx);\n\t\t\t\t\tif_block1.c();\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1, 1);\n\t\t\t\t\tif_block1.m(div4, null);\n\t\t\t\t}\n\t\t\t} else if (if_block1) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block1, 1, 1, () => {\n\t\t\t\t\tif_block1 = null;\n\t\t\t\t});\n\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();\n\t\t\t}\n\t\t},\n\t\ti: function intro(local) {\n\t\t\tif (current) return;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0);\n\n\t\t\tfor (let i = 0; i < each_value.length; i += 1) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(each_blocks[i]);\n\t\t\t}\n\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1);\n\t\t\tcurrent = true;\n\t\t},\n\t\to: function outro(local) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0);\n\t\t\teach_blocks = each_blocks.filter(Boolean);\n\n\t\t\tfor (let i = 0; i < each_blocks.length; i += 1) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(each_blocks[i]);\n\t\t\t}\n\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block1);\n\t\t\tcurrent = false;\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div6);\n\t\t\tif (if_block0) if_block0.d();\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_each)(each_blocks, detaching);\n\t\t\tif (if_block1) if_block1.d();\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_fragment.name,\n\t\ttype: "component",\n\t\tsource: "",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n\tlet votes;\n\tlet currentUserVotes;\n\tlet showMore;\n\tlet { $$slots: slots = {}, $$scope } = $$props;\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)(\'SingleQuestion\', slots, []);\n\tlet { question } = $$props;\n\tlet { options } = $$props;\n\tconsole.log("singleQuestion.svelte question: ");\n\tconsole.log(question);\n\tlet boxOpen = false;\n\n\tfunction toggleShow(showCondition) {\n\t\t$$invalidate(2, showMore = showCondition);\n\t\tconsole.log("showMore: " + showMore);\n\t}\n\n\t$$self.$$.on_mount.push(function () {\n\t\tif (question === undefined && !(\'question\' in $$props || $$self.$$.bound[$$self.$$.props[\'question\']])) {\n\t\t\tconsole_1.warn("<SingleQuestion> was created without expected prop \'question\'");\n\t\t}\n\n\t\tif (options === undefined && !(\'options\' in $$props || $$self.$$.bound[$$self.$$.props[\'options\']])) {\n\t\t\tconsole_1.warn("<SingleQuestion> was created without expected prop \'options\'");\n\t\t}\n\t});\n\n\tconst writable_props = [\'question\', \'options\'];\n\n\tObject.keys($$props).forEach(key => {\n\t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== \'$$\' && key !== \'slot\') console_1.warn(`<SingleQuestion> was created with unknown prop \'${key}\'`);\n\t});\n\n\t$$self.$$set = $$props => {\n\t\tif (\'question\' in $$props) $$invalidate(0, question = $$props.question);\n\t\tif (\'options\' in $$props) $$invalidate(1, options = $$props.options);\n\t};\n\n\t$$self.$capture_state = () => ({\n\t\tVoteButton: _voteButton_svelte__WEBPACK_IMPORTED_MODULE_4__["default"],\n\t\tSubmitForm: _submitForm_svelte__WEBPACK_IMPORTED_MODULE_3__["default"],\n\t\tSingleAnswer: _singleAnswer_svelte__WEBPACK_IMPORTED_MODULE_2__["default"],\n\t\tShowMore: _showMore_svelte__WEBPACK_IMPORTED_MODULE_1__["default"],\n\t\tquestion,\n\t\toptions,\n\t\tboxOpen,\n\t\ttoggleShow,\n\t\tshowMore,\n\t\tcurrentUserVotes,\n\t\tvotes\n\t});\n\n\t$$self.$inject_state = $$props => {\n\t\tif (\'question\' in $$props) $$invalidate(0, question = $$props.question);\n\t\tif (\'options\' in $$props) $$invalidate(1, options = $$props.options);\n\t\tif (\'boxOpen\' in $$props) boxOpen = $$props.boxOpen;\n\t\tif (\'showMore\' in $$props) $$invalidate(2, showMore = $$props.showMore);\n\t\tif (\'currentUserVotes\' in $$props) $$invalidate(3, currentUserVotes = $$props.currentUserVotes);\n\t\tif (\'votes\' in $$props) $$invalidate(4, votes = $$props.votes);\n\t};\n\n\tif ($$props && "$$inject" in $$props) {\n\t\t$$self.$inject_state($$props.$$inject);\n\t}\n\n\t$$self.$$.update = () => {\n\t\tif ($$self.$$.dirty & /*question*/ 1) {\n\t\t\t$: $$invalidate(4, votes = question.votes);\n\t\t}\n\n\t\tif ($$self.$$.dirty & /*question*/ 1) {\n\t\t\t$: $$invalidate(3, currentUserVotes = question.currentUserVotes);\n\t\t}\n\t};\n\n\t$: $$invalidate(2, showMore = false);\n\treturn [question, options, showMore, currentUserVotes, votes, toggleShow];\n}\n\nclass SingleQuestion extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {\n\tconstructor(options) {\n\t\tsuper(options);\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { question: 0, options: 1 });\n\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {\n\t\t\tcomponent: this,\n\t\t\ttagName: "SingleQuestion",\n\t\t\toptions,\n\t\t\tid: create_fragment.name\n\t\t});\n\t}\n\n\tget question() {\n\t\tthrow new Error("<SingleQuestion>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset question(value) {\n\t\tthrow new Error("<SingleQuestion>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tget options() {\n\t\tthrow new Error("<SingleQuestion>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset options(value) {\n\t\tthrow new Error("<SingleQuestion>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SingleQuestion);\n\n//# sourceURL=webpack://helpie-faq/./assets/js/svelte/qna/singleQuestion.svelte?')},"./assets/js/svelte/qna/submitForm.svelte":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");\n/* harmony import */ var _storeInstances_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storeInstances.js */ "./assets/js/svelte/qna/storeInstances.js");\n/* harmony import */ var C_Users_admin_Local_Sites_helpie_faq_app_public_wp_content_plugins_helpie_faq_assets_js_svelte_qna_submitForm_svelte_4_css_svelte_loader_cssPath_C_Users_admin_Local_Sites_helpie_faq_app_public_wp_content_plugins_helpie_faq_assets_js_svelte_qna_submitForm_svelte_4_css_C_Users_admin_Local_Sites_helpie_faq_app_public_wp_content_plugins_helpie_faq_assets_js_svelte_qna_submitForm_svelte__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assets/js/svelte/qna/submitForm.svelte.4.css!=!svelte-loader?cssPath=C:/Users/admin/Local Sites/helpie-faq/app/public/wp-content/plugins/helpie-faq/assets/js/svelte/qna/submitForm.svelte.4.css!./assets/js/svelte/qna/submitForm.svelte */ "./assets/js/svelte/qna/submitForm.svelte.4.css!=!./node_modules/svelte-loader/index.js?cssPath=C:/Users/admin/Local Sites/helpie-faq/app/public/wp-content/plugins/helpie-faq/assets/js/svelte/qna/submitForm.svelte.4.css!./assets/js/svelte/qna/submitForm.svelte");\n/* assets\\js\\svelte\\qna\\submitForm.svelte generated by Svelte v3.52.0 */\n\n\nconst { console: console_1 } = svelte_internal__WEBPACK_IMPORTED_MODULE_0__.globals;\n\nconst file = "assets\\\\js\\\\svelte\\\\qna\\\\submitForm.svelte";\n\n// (76:0) {:else}\nfunction create_else_block(ctx) {\n\tlet button;\n\tlet t0;\n\tlet t1;\n\tlet button_class_value;\n\tlet mounted;\n\tlet dispose;\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tbutton = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");\n\t\t\tt0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)("Add ");\n\t\t\tt1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(/*type*/ ctx[0]);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "class", button_class_value = "submit-qna " + /*type*/ ctx[0] + " svelte-12ihpky");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button, file, 76, 1, 1927);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, button, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, t0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, t1);\n\n\t\t\tif (!mounted) {\n\t\t\t\tdispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button, "click", /*onAddSubmissionClick*/ ctx[5], false, false, false);\n\t\t\t\tmounted = true;\n\t\t\t}\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tif (dirty & /*type*/ 1) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t1, /*type*/ ctx[0]);\n\n\t\t\tif (dirty & /*type*/ 1 && button_class_value !== (button_class_value = "submit-qna " + /*type*/ ctx[0] + " svelte-12ihpky")) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "class", button_class_value);\n\t\t\t}\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(button);\n\t\t\tmounted = false;\n\t\t\tdispose();\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_else_block.name,\n\t\ttype: "else",\n\t\tsource: "(76:0) {:else}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\n// (68:0) {#if showForm == true}\nfunction create_if_block(ctx) {\n\tlet textarea;\n\tlet textarea_placeholder_value;\n\tlet t0;\n\tlet button0;\n\tlet t1;\n\tlet t2;\n\tlet button0_class_value;\n\tlet t3;\n\tlet button1;\n\tlet mounted;\n\tlet dispose;\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\ttextarea = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("textarea");\n\t\t\tt0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tbutton0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");\n\t\t\tt1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)("Submit ");\n\t\t\tt2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(/*type*/ ctx[0]);\n\t\t\tt3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tbutton1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");\n\t\t\tbutton1.textContent = "Cancel";\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(textarea, "class", "submission__box");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(textarea, "placeholder", textarea_placeholder_value = "Add your " + /*type*/ ctx[0] + " here");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(textarea, file, 68, 1, 1677);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "class", button0_class_value = "submit-qna " + /*type*/ ctx[0] + " svelte-12ihpky");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button0, file, 73, 1, 1773);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button1, "class", "cancel-qna");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button1, file, 74, 1, 1852);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, textarea, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(textarea, /*value*/ ctx[1]);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t0, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, button0, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button0, t1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button0, t2);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t3, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, button1, anchor);\n\n\t\t\tif (!mounted) {\n\t\t\t\tdispose = [\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(textarea, "input", /*textarea_input_handler*/ ctx[8]),\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button0, "click", /*postItem*/ ctx[4], false, false, false),\n\t\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button1, "click", /*cancelQna*/ ctx[6], false, false, false)\n\t\t\t\t];\n\n\t\t\t\tmounted = true;\n\t\t\t}\n\t\t},\n\t\tp: function update(ctx, dirty) {\n\t\t\tif (dirty & /*type*/ 1 && textarea_placeholder_value !== (textarea_placeholder_value = "Add your " + /*type*/ ctx[0] + " here")) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(textarea, "placeholder", textarea_placeholder_value);\n\t\t\t}\n\n\t\t\tif (dirty & /*value*/ 2) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_input_value)(textarea, /*value*/ ctx[1]);\n\t\t\t}\n\n\t\t\tif (dirty & /*type*/ 1) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t2, /*type*/ ctx[0]);\n\n\t\t\tif (dirty & /*type*/ 1 && button0_class_value !== (button0_class_value = "submit-qna " + /*type*/ ctx[0] + " svelte-12ihpky")) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button0, "class", button0_class_value);\n\t\t\t}\n\t\t},\n\t\td: function destroy(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(textarea);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t0);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(button0);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t3);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(button1);\n\t\t\tmounted = false;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.run_all)(dispose);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block.name,\n\t\ttype: "if",\n\t\tsource: "(68:0) {#if showForm == true}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\nfunction create_fragment(ctx) {\n\tlet html_tag;\n\tlet t;\n\tlet if_block_anchor;\n\n\tfunction select_block_type(ctx, dirty) {\n\t\tif (/*showForm*/ ctx[2] == true) return create_if_block;\n\t\treturn create_else_block;\n\t}\n\n\tlet current_block_type = select_block_type(ctx, -1);\n\tlet if_block = current_block_type(ctx);\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\thtml_tag = new svelte_internal__WEBPACK_IMPORTED_MODULE_0__.HtmlTag(false);\n\t\t\tt = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tif_block.c();\n\t\t\tif_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();\n\t\t\thtml_tag.a = t;\n\t\t},\n\t\tl: function claim(nodes) {\n\t\t\tthrow new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\thtml_tag.m(/*submissionMessage*/ ctx[3], target, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, t, anchor);\n\t\t\tif_block.m(target, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, if_block_anchor, anchor);\n\t\t},\n\t\tp: function update(ctx, [dirty]) {\n\t\t\tif (dirty & /*submissionMessage*/ 8) html_tag.p(/*submissionMessage*/ ctx[3]);\n\n\t\t\tif (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {\n\t\t\t\tif_block.p(ctx, dirty);\n\t\t\t} else {\n\t\t\t\tif_block.d(1);\n\t\t\t\tif_block = current_block_type(ctx);\n\n\t\t\t\tif (if_block) {\n\t\t\t\t\tif_block.c();\n\t\t\t\t\tif_block.m(if_block_anchor.parentNode, if_block_anchor);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\ti: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\to: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\td: function destroy(detaching) {\n\t\t\tif (detaching) html_tag.d();\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(t);\n\t\t\tif_block.d(detaching);\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(if_block_anchor);\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_fragment.name,\n\t\ttype: "component",\n\t\tsource: "",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n\tlet showForm;\n\tlet submissionMessage;\n\tlet { $$slots: slots = {}, $$scope } = $$props;\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)(\'SubmitForm\', slots, []);\n\tlet { type = "question" } = $$props;\n\tlet { questionId = 0 } = $$props;\n\tlet value = "";\n\tlet submissionStatus = "";\n\tconsole.log("helpie_faq_object.current_post_id: " + helpie_faq_object.current_post_id);\n\n\tfunction updateForm(JsonResponse) {\n\t\tlet response = JSON.parse(JsonResponse);\n\t\tconsole.log("submitForm response: ");\n\t\tconsole.log(response);\n\t\tsubmissionStatus = response.status;\n\n\t\tif (response.status == "published" || response.status == "awaiting") {\n\t\t\t$$invalidate(2, showForm = false);\n\t\t}\n\n\t\t$$invalidate(1, value = "");\n\t\t$$invalidate(3, submissionMessage = "<p class=\'message\'>" + response.message + "</p>");\n\t\tconsole.log("submissionMessage: " + submissionMessage);\n\t}\n\n\tasync function postItem() {\n\t\tlet loadingImageUrl = helpie_faq_object.url + "assets/img/moving-train.gif";\n\n\t\t// submissionMessage = "Submitting... Do not refresh.";\n\t\t$$invalidate(3, submissionMessage = "<img class=\'gif\' src=\'" + loadingImageUrl + "\' alt=\'Loading\'/>");\n\n\t\tlet postargs = {\n\t\t\taction: "helpie_qna_add_post",\n\t\t\tnonce: thisModule.nonce,\n\t\t\tcurrent_post_id: helpie_faq_object.current_post_id,\n\t\t\ttype,\n\t\t\tquestion_id: questionId,\n\t\t\tvalue\n\t\t};\n\n\t\tconsole.log("postargs: ");\n\t\tconsole.log(postargs);\n\t\tlet response = await _storeInstances_js__WEBPACK_IMPORTED_MODULE_1__["default"].postItem(postargs);\n\t\tawait updateForm(response);\n\t}\n\n\tfunction onAddSubmissionClick() {\n\t\t$$invalidate(2, showForm = true);\n\t}\n\n\tfunction cancelQna() {\n\t\t$$invalidate(2, showForm = false);\n\t}\n\n\tconst writable_props = [\'type\', \'questionId\'];\n\n\tObject.keys($$props).forEach(key => {\n\t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== \'$$\' && key !== \'slot\') console_1.warn(`<SubmitForm> was created with unknown prop \'${key}\'`);\n\t});\n\n\tfunction textarea_input_handler() {\n\t\tvalue = this.value;\n\t\t$$invalidate(1, value);\n\t}\n\n\t$$self.$$set = $$props => {\n\t\tif (\'type\' in $$props) $$invalidate(0, type = $$props.type);\n\t\tif (\'questionId\' in $$props) $$invalidate(7, questionId = $$props.questionId);\n\t};\n\n\t$$self.$capture_state = () => ({\n\t\tStoreInstance: _storeInstances_js__WEBPACK_IMPORTED_MODULE_1__["default"],\n\t\ttype,\n\t\tquestionId,\n\t\tvalue,\n\t\tsubmissionStatus,\n\t\tupdateForm,\n\t\tpostItem,\n\t\tonAddSubmissionClick,\n\t\tcancelQna,\n\t\tshowForm,\n\t\tsubmissionMessage\n\t});\n\n\t$$self.$inject_state = $$props => {\n\t\tif (\'type\' in $$props) $$invalidate(0, type = $$props.type);\n\t\tif (\'questionId\' in $$props) $$invalidate(7, questionId = $$props.questionId);\n\t\tif (\'value\' in $$props) $$invalidate(1, value = $$props.value);\n\t\tif (\'submissionStatus\' in $$props) submissionStatus = $$props.submissionStatus;\n\t\tif (\'showForm\' in $$props) $$invalidate(2, showForm = $$props.showForm);\n\t\tif (\'submissionMessage\' in $$props) $$invalidate(3, submissionMessage = $$props.submissionMessage);\n\t};\n\n\tif ($$props && "$$inject" in $$props) {\n\t\t$$self.$inject_state($$props.$$inject);\n\t}\n\n\t$: $$invalidate(2, showForm = false);\n\t$: $$invalidate(3, submissionMessage = "");\n\n\treturn [\n\t\ttype,\n\t\tvalue,\n\t\tshowForm,\n\t\tsubmissionMessage,\n\t\tpostItem,\n\t\tonAddSubmissionClick,\n\t\tcancelQna,\n\t\tquestionId,\n\t\ttextarea_input_handler\n\t];\n}\n\nclass SubmitForm extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {\n\tconstructor(options) {\n\t\tsuper(options);\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { type: 0, questionId: 7 });\n\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {\n\t\t\tcomponent: this,\n\t\t\ttagName: "SubmitForm",\n\t\t\toptions,\n\t\t\tid: create_fragment.name\n\t\t});\n\t}\n\n\tget type() {\n\t\tthrow new Error("<SubmitForm>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset type(value) {\n\t\tthrow new Error("<SubmitForm>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tget questionId() {\n\t\tthrow new Error("<SubmitForm>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset questionId(value) {\n\t\tthrow new Error("<SubmitForm>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SubmitForm);\n\n\n//# sourceURL=webpack://helpie-faq/./assets/js/svelte/qna/submitForm.svelte?')},"./assets/js/svelte/qna/voteButton.svelte":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");\n/* harmony import */ var _storeInstances_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storeInstances.js */ "./assets/js/svelte/qna/storeInstances.js");\n/* assets\\js\\svelte\\qna\\voteButton.svelte generated by Svelte v3.52.0 */\n\n\nconst { console: console_1 } = svelte_internal__WEBPACK_IMPORTED_MODULE_0__.globals;\n\nconst file = "assets\\\\js\\\\svelte\\\\qna\\\\voteButton.svelte";\n\n// (100:2) {#if options["showDownVote"] == true}\nfunction create_if_block(ctx) {\n\tlet button;\n\tlet span0;\n\tlet span0_class_value;\n\tlet t0;\n\tlet span1;\n\tlet mounted;\n\tlet dispose;\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tbutton = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");\n\t\t\tspan0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");\n\t\t\tt0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tspan1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");\n\t\t\tspan1.textContent = `${/*downVotes*/ ctx[3]}`;\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span0, "class", span0_class_value = "icon " + get_icon(\'arrow\', \'down\') + "");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span0, file, 101, 4, 2422);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span1, "class", "vote_count");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span1, file, 102, 4, 2478);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "class", "single down");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button, file, 100, 3, 2354);\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, button, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, span0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, t0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, span1);\n\n\t\t\tif (!mounted) {\n\t\t\t\tdispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button, "click", /*click_handler_1*/ ctx[11], false, false, false);\n\t\t\t\tmounted = true;\n\t\t\t}\n\t\t},\n\t\tp: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\td: function destroy(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(button);\n\t\t\tmounted = false;\n\t\t\tdispose();\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_if_block.name,\n\t\ttype: "if",\n\t\tsource: "(100:2) {#if options[\\\\\\"showDownVote\\\\\\"] == true}",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\nfunction create_fragment(ctx) {\n\tlet div1;\n\tlet div0;\n\tlet button;\n\tlet span0;\n\tlet span0_class_value;\n\tlet t0;\n\tlet span1;\n\tlet t1;\n\tlet button_class_value;\n\tlet t2;\n\tlet mounted;\n\tlet dispose;\n\tlet if_block = /*options*/ ctx[0]["showDownVote"] == true && create_if_block(ctx);\n\n\tconst block = {\n\t\tc: function create() {\n\t\t\tdiv1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tdiv0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");\n\t\t\tbutton = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("button");\n\t\t\tspan0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");\n\t\t\tt0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tspan1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");\n\t\t\tt1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(/*upVotes*/ ctx[2]);\n\t\t\tt2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();\n\t\t\tif (if_block) if_block.c();\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span0, "class", span0_class_value = "icon " + get_icon(\'arrow\', \'up\') + "");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span0, file, 95, 3, 2199);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(span1, "class", "vote_count");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(span1, file, 96, 3, 2252);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "class", button_class_value = "single up blue " + (/*alreadyVoted*/ ctx[1] ? \'alreadyVoted\' : \'\'));\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(button, file, 91, 2, 2082);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div0, "class", "helpiefaq__votebutton__group");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div0, file, 90, 1, 2036);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(div1, "class", "helpiefaq__vote__container");\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_location)(div1, file, 89, 0, 1993);\n\t\t},\n\t\tl: function claim(nodes) {\n\t\t\tthrow new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");\n\t\t},\n\t\tm: function mount(target, anchor) {\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert_dev)(target, div1, anchor);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div1, div0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, button);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, span0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, t0);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(button, span1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(span1, t1);\n\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append_dev)(div0, t2);\n\t\t\tif (if_block) if_block.m(div0, null);\n\n\t\t\tif (!mounted) {\n\t\t\t\tdispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen_dev)(button, "click", /*click_handler*/ ctx[10], false, false, false);\n\t\t\t\tmounted = true;\n\t\t\t}\n\t\t},\n\t\tp: function update(ctx, [dirty]) {\n\t\t\tif (dirty & /*upVotes*/ 4) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data_dev)(t1, /*upVotes*/ ctx[2]);\n\n\t\t\tif (dirty & /*alreadyVoted*/ 2 && button_class_value !== (button_class_value = "single up blue " + (/*alreadyVoted*/ ctx[1] ? \'alreadyVoted\' : \'\'))) {\n\t\t\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr_dev)(button, "class", button_class_value);\n\t\t\t}\n\n\t\t\tif (/*options*/ ctx[0]["showDownVote"] == true) {\n\t\t\t\tif (if_block) {\n\t\t\t\t\tif_block.p(ctx, dirty);\n\t\t\t\t} else {\n\t\t\t\t\tif_block = create_if_block(ctx);\n\t\t\t\t\tif_block.c();\n\t\t\t\t\tif_block.m(div0, null);\n\t\t\t\t}\n\t\t\t} else if (if_block) {\n\t\t\t\tif_block.d(1);\n\t\t\t\tif_block = null;\n\t\t\t}\n\t\t},\n\t\ti: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\to: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,\n\t\td: function destroy(detaching) {\n\t\t\tif (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach_dev)(div1);\n\t\t\tif (if_block) if_block.d();\n\t\t\tmounted = false;\n\t\t\tdispose();\n\t\t}\n\t};\n\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterBlock", {\n\t\tblock,\n\t\tid: create_fragment.name,\n\t\ttype: "component",\n\t\tsource: "",\n\t\tctx\n\t});\n\n\treturn block;\n}\n\nfunction get_icon(iconType, direction) {\n\tlet icons = {\n\t\tarrow1: "dashicons dashicons-arrow-" + direction + "-alt",\n\t\tarrow2: "dashicons dashicons-arrow-" + direction + "-alt2",\n\t\tarrow: "dashicons dashicons-arrow-" + direction + "",\n\t\tthumbs: "dashicons dashicons-thumbs-" + direction + ""\n\t};\n\n\treturn icons[iconType];\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n\tlet upVotes;\n\tlet { $$slots: slots = {}, $$scope } = $$props;\n\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.validate_slots)(\'VoteButton\', slots, []);\n\tlet { options } = $$props;\n\tlet { voteFor = "question" } = $$props;\n\tlet { questionId = 0 } = $$props;\n\tlet { answerCommentId = 0 } = $$props;\n\tlet { votes = { up: 0, down: 0 } } = $$props;\n\tlet { currentUserVotes = {} } = $$props;\n\tconsole.log("currentUserVotes: ");\n\tconsole.log(currentUserVotes);\n\tlet alreadyVoted = false;\n\tlet downVotes = votes.down;\n\n\tfunction initVoteStatus() {\n\t\t$$invalidate(1, alreadyVoted = false);\n\n\t\tif (currentUserVotes && currentUserVotes.vote) {\n\t\t\t$$invalidate(1, alreadyVoted = true);\n\t\t}\n\n\t\tconsole.log("initVoteStatus alreadyVoted :");\n\t\tconsole.log(alreadyVoted);\n\t}\n\n\tinitVoteStatus();\n\n\tfunction postVote(vote, actionType = "add") {\n\t\tconsole.log("vote: " + vote);\n\t\tconsole.log("alreadyVoted: " + alreadyVoted);\n\n\t\tvar reqData = {\n\t\t\taction: "helpie_handle_vote",\n\t\t\tnonce: thisModule.nonce,\n\t\t\tvote,\n\t\t\taction_type: actionType,\n\t\t\tvote_for: voteFor,\n\t\t\tquestion_id: questionId,\n\t\t\tanswer_comment_id: answerCommentId,\n\t\t\tcurrent_post_id: helpie_faq_object.current_post_id\n\t\t};\n\n\t\tif (alreadyVoted) {\n\t\t\treqData["action_type"] = "remove";\n\t\t\t$$invalidate(1, alreadyVoted = false);\n\t\t\t$$invalidate(2, upVotes--, upVotes);\n\t\t} else {\n\t\t\t$$invalidate(2, upVotes++, upVotes);\n\t\t\t$$invalidate(1, alreadyVoted = true);\n\t\t}\n\n\t\tconsole.log("alreadyVoted: " + alreadyVoted);\n\t\tconsole.log("reqData: ");\n\t\tconsole.log(reqData);\n\t\t_storeInstances_js__WEBPACK_IMPORTED_MODULE_1__["default"].postVote(reqData);\n\t} // if (vote == "up") {\n\t// \tupVotes++;\n\n\t$$self.$$.on_mount.push(function () {\n\t\tif (options === undefined && !(\'options\' in $$props || $$self.$$.bound[$$self.$$.props[\'options\']])) {\n\t\t\tconsole_1.warn("<VoteButton> was created without expected prop \'options\'");\n\t\t}\n\t});\n\n\tconst writable_props = [\n\t\t\'options\',\n\t\t\'voteFor\',\n\t\t\'questionId\',\n\t\t\'answerCommentId\',\n\t\t\'votes\',\n\t\t\'currentUserVotes\'\n\t];\n\n\tObject.keys($$props).forEach(key => {\n\t\tif (!~writable_props.indexOf(key) && key.slice(0, 2) !== \'$$\' && key !== \'slot\') console_1.warn(`<VoteButton> was created with unknown prop \'${key}\'`);\n\t});\n\n\tconst click_handler = () => postVote("up");\n\tconst click_handler_1 = () => postVote("down");\n\n\t$$self.$$set = $$props => {\n\t\tif (\'options\' in $$props) $$invalidate(0, options = $$props.options);\n\t\tif (\'voteFor\' in $$props) $$invalidate(5, voteFor = $$props.voteFor);\n\t\tif (\'questionId\' in $$props) $$invalidate(6, questionId = $$props.questionId);\n\t\tif (\'answerCommentId\' in $$props) $$invalidate(7, answerCommentId = $$props.answerCommentId);\n\t\tif (\'votes\' in $$props) $$invalidate(8, votes = $$props.votes);\n\t\tif (\'currentUserVotes\' in $$props) $$invalidate(9, currentUserVotes = $$props.currentUserVotes);\n\t};\n\n\t$$self.$capture_state = () => ({\n\t\tStoreInstance: _storeInstances_js__WEBPACK_IMPORTED_MODULE_1__["default"],\n\t\toptions,\n\t\tvoteFor,\n\t\tquestionId,\n\t\tanswerCommentId,\n\t\tvotes,\n\t\tcurrentUserVotes,\n\t\talreadyVoted,\n\t\tdownVotes,\n\t\tinitVoteStatus,\n\t\tget_icon,\n\t\tpostVote,\n\t\tupVotes\n\t});\n\n\t$$self.$inject_state = $$props => {\n\t\tif (\'options\' in $$props) $$invalidate(0, options = $$props.options);\n\t\tif (\'voteFor\' in $$props) $$invalidate(5, voteFor = $$props.voteFor);\n\t\tif (\'questionId\' in $$props) $$invalidate(6, questionId = $$props.questionId);\n\t\tif (\'answerCommentId\' in $$props) $$invalidate(7, answerCommentId = $$props.answerCommentId);\n\t\tif (\'votes\' in $$props) $$invalidate(8, votes = $$props.votes);\n\t\tif (\'currentUserVotes\' in $$props) $$invalidate(9, currentUserVotes = $$props.currentUserVotes);\n\t\tif (\'alreadyVoted\' in $$props) $$invalidate(1, alreadyVoted = $$props.alreadyVoted);\n\t\tif (\'downVotes\' in $$props) $$invalidate(3, downVotes = $$props.downVotes);\n\t\tif (\'upVotes\' in $$props) $$invalidate(2, upVotes = $$props.upVotes);\n\t};\n\n\tif ($$props && "$$inject" in $$props) {\n\t\t$$self.$inject_state($$props.$$inject);\n\t}\n\n\t$$self.$$.update = () => {\n\t\tif ($$self.$$.dirty & /*votes*/ 256) {\n\t\t\t$: $$invalidate(2, upVotes = votes.up);\n\t\t}\n\t};\n\n\treturn [\n\t\toptions,\n\t\talreadyVoted,\n\t\tupVotes,\n\t\tdownVotes,\n\t\tpostVote,\n\t\tvoteFor,\n\t\tquestionId,\n\t\tanswerCommentId,\n\t\tvotes,\n\t\tcurrentUserVotes,\n\t\tclick_handler,\n\t\tclick_handler_1\n\t];\n}\n\nclass VoteButton extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev {\n\tconstructor(options) {\n\t\tsuper(options);\n\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {\n\t\t\toptions: 0,\n\t\t\tvoteFor: 5,\n\t\t\tquestionId: 6,\n\t\t\tanswerCommentId: 7,\n\t\t\tvotes: 8,\n\t\t\tcurrentUserVotes: 9\n\t\t});\n\n\t\t(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dispatch_dev)("SvelteRegisterComponent", {\n\t\t\tcomponent: this,\n\t\t\ttagName: "VoteButton",\n\t\t\toptions,\n\t\t\tid: create_fragment.name\n\t\t});\n\t}\n\n\tget options() {\n\t\tthrow new Error("<VoteButton>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset options(value) {\n\t\tthrow new Error("<VoteButton>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tget voteFor() {\n\t\tthrow new Error("<VoteButton>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset voteFor(value) {\n\t\tthrow new Error("<VoteButton>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tget questionId() {\n\t\tthrow new Error("<VoteButton>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset questionId(value) {\n\t\tthrow new Error("<VoteButton>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tget answerCommentId() {\n\t\tthrow new Error("<VoteButton>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset answerCommentId(value) {\n\t\tthrow new Error("<VoteButton>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tget votes() {\n\t\tthrow new Error("<VoteButton>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset votes(value) {\n\t\tthrow new Error("<VoteButton>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tget currentUserVotes() {\n\t\tthrow new Error("<VoteButton>: Props cannot be read directly from the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n\n\tset currentUserVotes(value) {\n\t\tthrow new Error("<VoteButton>: Props cannot be set directly on the component instance unless compiling with \'accessors: true\' or \'<svelte:options accessors/>\'");\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VoteButton);\n\n//# sourceURL=webpack://helpie-faq/./assets/js/svelte/qna/voteButton.svelte?')},"./node_modules/svelte/index.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "onMount": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.onMount)\n/* harmony export */ });\n/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/index.mjs */ "./node_modules/svelte/internal/index.mjs");\n\n\n\n//# sourceURL=webpack://helpie-faq/./node_modules/svelte/index.mjs?')},"./node_modules/svelte/internal/index.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HtmlTag\": () => (/* binding */ HtmlTag),\n/* harmony export */   \"SvelteComponentDev\": () => (/* binding */ SvelteComponentDev),\n/* harmony export */   \"add_location\": () => (/* binding */ add_location),\n/* harmony export */   \"add_render_callback\": () => (/* binding */ add_render_callback),\n/* harmony export */   \"append_dev\": () => (/* binding */ append_dev),\n/* harmony export */   \"attr_dev\": () => (/* binding */ attr_dev),\n/* harmony export */   \"check_outros\": () => (/* binding */ check_outros),\n/* harmony export */   \"create_component\": () => (/* binding */ create_component),\n/* harmony export */   \"destroy_component\": () => (/* binding */ destroy_component),\n/* harmony export */   \"destroy_each\": () => (/* binding */ destroy_each),\n/* harmony export */   \"detach_dev\": () => (/* binding */ detach_dev),\n/* harmony export */   \"dispatch_dev\": () => (/* binding */ dispatch_dev),\n/* harmony export */   \"element\": () => (/* binding */ element),\n/* harmony export */   \"empty\": () => (/* binding */ empty),\n/* harmony export */   \"get_store_value\": () => (/* binding */ get_store_value),\n/* harmony export */   \"globals\": () => (/* binding */ globals),\n/* harmony export */   \"group_outros\": () => (/* binding */ group_outros),\n/* harmony export */   \"handle_promise\": () => (/* binding */ handle_promise),\n/* harmony export */   \"init\": () => (/* binding */ init),\n/* harmony export */   \"insert_dev\": () => (/* binding */ insert_dev),\n/* harmony export */   \"is_function\": () => (/* binding */ is_function),\n/* harmony export */   \"listen_dev\": () => (/* binding */ listen_dev),\n/* harmony export */   \"mount_component\": () => (/* binding */ mount_component),\n/* harmony export */   \"noop\": () => (/* binding */ noop),\n/* harmony export */   \"onMount\": () => (/* binding */ onMount),\n/* harmony export */   \"run_all\": () => (/* binding */ run_all),\n/* harmony export */   \"safe_not_equal\": () => (/* binding */ safe_not_equal),\n/* harmony export */   \"set_data_dev\": () => (/* binding */ set_data_dev),\n/* harmony export */   \"set_input_value\": () => (/* binding */ set_input_value),\n/* harmony export */   \"set_style\": () => (/* binding */ set_style),\n/* harmony export */   \"space\": () => (/* binding */ space),\n/* harmony export */   \"src_url_equal\": () => (/* binding */ src_url_equal),\n/* harmony export */   \"subscribe\": () => (/* binding */ subscribe),\n/* harmony export */   \"text\": () => (/* binding */ text),\n/* harmony export */   \"toggle_class\": () => (/* binding */ toggle_class),\n/* harmony export */   \"transition_in\": () => (/* binding */ transition_in),\n/* harmony export */   \"transition_out\": () => (/* binding */ transition_out),\n/* harmony export */   \"update_await_block_branch\": () => (/* binding */ update_await_block_branch),\n/* harmony export */   \"validate_each_argument\": () => (/* binding */ validate_each_argument),\n/* harmony export */   \"validate_slots\": () => (/* binding */ validate_slots)\n/* harmony export */ });\n/* unused harmony exports HtmlTagHydration, SvelteComponent, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_resize_listener, add_styles, add_transform, afterUpdate, append, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, construct_svelte_component, construct_svelte_component_dev, createEventDispatcher, create_animation, create_bidirectional_transition, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, detach, detach_after_dev, detach_before_dev, detach_between_dev, dirty_components, each, element_is, end_hydrating, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, hasContext, has_prop, head_selector, identity, insert, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_promise, is_void, listen, loop, loop_guard, merge_ssr_styles, missing_component, not_equal, now, null_to_empty, object_without_properties, onDestroy, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_custom_element_data_map, set_data, set_input_type, set_now, set_raf, set_store_value, set_svg_attributes, spread, start_hydrating, stop_propagation, svg_element, tick, time_ranges_to_array, to_number, trusted, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_keys, validate_store, validate_void_dynamic_element, xlink_attr */\nfunction noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n    return style.sheet;\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data_map(node, data_map) {\n    Object.keys(data_map).forEach((key) => {\n        set_custom_element_data(node, key, data_map[key]);\n    });\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value === null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nfunction head_selector(nodeId, head) {\n    const result = [];\n    let started = 0;\n    for (const node of head.childNodes) {\n        if (node.nodeType === 8 /* comment node */) {\n            const comment = node.textContent.trim();\n            if (comment === `HEAD_${nodeId}_END`) {\n                started -= 1;\n                result.push(node);\n            }\n            else if (comment === `HEAD_${nodeId}_START`) {\n                started += 1;\n                result.push(node);\n            }\n        }\n        else if (started > 0) {\n            result.push(node);\n        }\n    }\n    return result;\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            else\n                this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\nfunction construct_svelte_component(component, props) {\n    return new component(props);\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { ownerNode } = info.stylesheet;\n            // there is no ownerNode if it runs on jsdom.\n            if (ownerNode)\n                detach(ownerNode);\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs#run-time-svelte-beforeupdate\n */\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs#run-time-svelte-onmount\n */\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n */\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs#run-time-svelte-ondestroy\n */\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * https://svelte.dev/docs#run-time-svelte-createeventdispatcher\n */\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-setcontext\n */\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-getcontext\n */\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs#run-time-svelte-getallcontexts\n */\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-hascontext\n */\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        while (flushidx < dirty_components.length) {\n            const component = dirty_components[flushidx];\n            flushidx++;\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n    else if (callback) {\n        callback();\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'inert',\n    'ismap',\n    'itemscope',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\n/** regex of all html void element names */\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nfunction escape(value, is_attr = false) {\n    const str = String(value);\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n    pattern.lastIndex = 0;\n    let escaped = '';\n    let last = 0;\n    while (pattern.test(str)) {\n        const i = pattern.lastIndex - 1;\n        const ch = str[i];\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n        last = i + 1;\n    }\n    return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n    // keep booleans, null, and undefined for the sake of `spread`\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\n    return should_escape ? escape(value, true) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${style_object[key]};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n            // if the component was destroyed immediately\n            // it will update the `$$.on_destroy` reference to `null`.\n            // the destructured on_destroy may still reference to the old array\n            if (component.$$.on_destroy) {\n                component.$$.on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: [],\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            if (!is_function(callback)) {\n                return noop;\n            }\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        if (!is_function(callback)) {\n            return noop;\n        }\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.52.0' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\nfunction construct_svelte_component_dev(component, props) {\n    const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n    try {\n        const instance = new component(props);\n        if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n            throw new Error(error_message);\n        }\n        return instance;\n    }\n    catch (err) {\n        const { message } = err;\n        if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n            throw new Error(error_message);\n        }\n        else {\n            throw err;\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * <\/script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\n\n\n\n//# sourceURL=webpack://helpie-faq/./node_modules/svelte/internal/index.mjs?")},"./node_modules/svelte/store/index.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "derived": () => (/* binding */ derived),\n/* harmony export */   "get": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.get_store_value),\n/* harmony export */   "writable": () => (/* binding */ writable)\n/* harmony export */ });\n/* unused harmony export readable */\n/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/index.mjs */ "./node_modules/svelte/internal/index.mjs");\n\n\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if ((0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal)(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.is_function)(result) ? result : _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.subscribe)(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.run_all)(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\n\n\n\n//# sourceURL=webpack://helpie-faq/./node_modules/svelte/store/index.mjs?')}},__webpack_module_cache__={};function __webpack_require__(t){var n=__webpack_module_cache__[t];if(void 0!==n)return n.exports;var e=__webpack_module_cache__[t]={exports:{}};return __webpack_modules__[t](e,e.exports,__webpack_require__),e.exports}__webpack_require__.d=(t,n)=>{for(var e in n)__webpack_require__.o(n,e)&&!__webpack_require__.o(t,e)&&Object.defineProperty(t,e,{enumerable:!0,get:n[e]})},__webpack_require__.o=(t,n)=>Object.prototype.hasOwnProperty.call(t,n);var __webpack_exports__=__webpack_require__("./assets/js/main.js")})();